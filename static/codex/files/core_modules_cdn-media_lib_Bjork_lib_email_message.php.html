<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/modules/cdn-media/lib/Bjork/lib/email/message.php - wp-flawless</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://a3d72a45d111006ec192-ec5b80a12b0b09b4d52373336afb4254.r80.cf1.rackcdn.com/usability-dynamics.png" title="wp-flawless"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/API.html">API</a></li>
            
                <li><a href="../classes/Carrington.html">Carrington</a></li>
            
                <li><a href="../classes/Extended_Taxonomies.html">Extended_Taxonomies</a></li>
            
                <li><a href="../classes/Flawless.API.html">Flawless.API</a></li>
            
                <li><a href="../classes/Flawless.Asset.html">Flawless.Asset</a></li>
            
                <li><a href="../classes/Flawless.Branded_Login.html">Flawless.Branded_Login</a></li>
            
                <li><a href="../classes/Flawless.BuddyPress.html">Flawless.BuddyPress</a></li>
            
                <li><a href="../classes/Flawless.Content.html">Flawless.Content</a></li>
            
                <li><a href="../classes/Flawless.Element.html">Flawless.Element</a></li>
            
                <li><a href="../classes/Flawless.Flawless\Shortcode.html">Flawless.Flawless\Shortcode</a></li>
            
                <li><a href="../classes/Flawless.Management.html">Flawless.Management</a></li>
            
                <li><a href="../classes/Flawless.Mobile.html">Flawless.Mobile</a></li>
            
                <li><a href="../classes/Flawless.Navbars.html">Flawless.Navbars</a></li>
            
                <li><a href="../classes/Flawless.Schema.html">Flawless.Schema</a></li>
            
                <li><a href="../classes/Flawless.Settings.html">Flawless.Settings</a></li>
            
                <li><a href="../classes/Flawless.Styles.html">Flawless.Styles</a></li>
            
                <li><a href="../classes/Flawless.Utility.html">Flawless.Utility</a></li>
            
                <li><a href="../classes/Flawless.Widget.html">Flawless.Widget</a></li>
            
                <li><a href="../classes/flawless_wpp_extensions.html">flawless_wpp_extensions</a></li>
            
                <li><a href="../classes/Legacy.html">Legacy</a></li>
            
                <li><a href="../classes/License.html">License</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Log.html">Log</a></li>
            
                <li><a href="../classes/Maintenance.html">Maintenance</a></li>
            
                <li><a href="../classes/Models.html">Models</a></li>
            
                <li><a href="../classes/Module.html">Module</a></li>
            
                <li><a href="../classes/Multisite.html">Multisite</a></li>
            
                <li><a href="../classes/SaaS.html">SaaS</a></li>
            
                <li><a href="../classes/Shortcode.html">Shortcode</a></li>
            
                <li><a href="../classes/Shortcodes.html">Shortcodes</a></li>
            
                <li><a href="../classes/Template Methods.html">Template Methods</a></li>
            
                <li><a href="../classes/Theme.html">Theme</a></li>
            
                <li><a href="../classes/UI.html">UI</a></li>
            
                <li><a href="../classes/Utility.html">Utility</a></li>
            
                <li><a href="../classes/Views.html">Views</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/API.html">API</a></li>
            
                <li><a href="../modules/Branded Login.html">Branded Login</a></li>
            
                <li><a href="../modules/Carrington.html">Carrington</a></li>
            
                <li><a href="../modules/Carrington Build.html">Carrington Build</a></li>
            
                <li><a href="../modules/carrington-build.html">carrington-build</a></li>
            
                <li><a href="../modules/cfct_build.html">cfct_build</a></li>
            
                <li><a href="../modules/default.html">default</a></li>
            
                <li><a href="../modules/Flawless.html">Flawless</a></li>
            
                <li><a href="../modules/Loader.html">Loader</a></li>
            
                <li><a href="../modules/Log.html">Log</a></li>
            
                <li><a href="../modules/Maintenence.html">Maintenence</a></li>
            
                <li><a href="../modules/Management.html">Management</a></li>
            
                <li><a href="../modules/Multisite.html">Multisite</a></li>
            
                <li><a href="../modules/SaaS.html">SaaS</a></li>
            
                <li><a href="../modules/Services_JSON.html">Services_JSON</a></li>
            
                <li><a href="../modules/Shortcodes.html">Shortcodes</a></li>
            
                <li><a href="../modules/taxonomy-landing

This file is part of Taxonomy Landing for WordPress
http:__github.com_crowdfavorite_wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http:__crowdfavorite.com

Released under the GPL license
http:__www.opensource.org_licenses_gpl-license.php

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************.html">taxonomy-landing

This file is part of Taxonomy Landing for WordPress
http://github.com/crowdfavorite/wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http://crowdfavorite.com

Released under the GPL license
http://www.opensource.org/licenses/gpl-license.php

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************</a></li>
            
                <li><a href="../modules/taxonomy-landing

This file is part of Taxonomy Landing for WordPress
https:__github.com_crowdfavorite_wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http:__crowdfavorite.com

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************.html">taxonomy-landing

This file is part of Taxonomy Landing for WordPress
https://github.com/crowdfavorite/wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http://crowdfavorite.com

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************</a></li>
            
                <li><a href="../modules/Theme UI.html">Theme UI</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
                <li><a href="../modules/UsabilityDynamics.html">UsabilityDynamics</a></li>
            
                <li><a href="../modules/Utility.html">Utility</a></li>
            
                <li><a href="../modules/Views.html">Views</a></li>
            
                <li><a href="../modules/WP-Property.html">WP-Property</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/modules/cdn-media/lib/Bjork/lib/email/message.php</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&lt;?php

namespace email\message;

use strutils;

use email\charset\Charset,
    email\generator\Generator,
    email\encoders,
    email\utils;

const SEMISPACE = &#x27;; &#x27;;
const TSPECIALS_RE = &#x27;/[ \(\)&lt;&gt;@,;:\\&quot;\/\[\]\?=]/u&#x27;;

/**
* Prepare string to be used in a quoted string.
* 
* Turns backslash and double quote characters into quoted pairs.  These
* are the only characters that need to be quoted inside a quoted string.
* Does not add the surrounding double quotes.
*/
function quote($str) {
    return str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&#x27;\\&#x27;, &#x27;\\\\&#x27;, $str));
}

/**
* Split header parameters.  BAW: this may be too simple.  It isn&#x27;t
* strictly RFC 2045 (section 5.1) compliant, but it catches most headers
* found in the wild.  We may eventually need a full fledged parser
* eventually.
*/
function splitparam($param) {
    list($a, $sep, $b) = strutils::partition($param, &#x27;;&#x27;);
    if (!$sep)
        return array(trim($a), null);
    return array(trim($a), trim($b));
}

/*
* Convenience function to format and return a key=value pair.
*
* This will quote the value if needed or if quote is true.  If value is a
* three tuple (charset, language, value), it will be encoded according
* to RFC2231 rules.
*/
function formatparam($param, $value=null, $quote=true) {
    if ($value !== 0 &amp;&amp; $value) {
        if (is_array($value)) {
            $param .= &#x27;*&#x27;;
            $value = utils::encode_rfc2231($value[2], $value[0], $value[1]);
        }
        if ($quote || preg_match(TSPECIALS_RE, $value))
            return sprintf(&#x27;%s=&quot;%s&quot;&#x27;, $param, quote($value));
        else
            return sprintf(&#x27;%s=%s&#x27;, $param, $value);
    } else {
        return $param;
    }
}

function parseparam($str) {
    static $o = 0;
    $o++;
    $s = $str;
    $plist = array();
    while (strutils::startswith($s, &#x27;;&#x27;)) {
        $s = ltrim($s, &#x27;;&#x27;);
        $end = mb_strpos($s, &#x27;;&#x27;);
        while ($end &gt; 0 &amp;&amp; (substr_count($s, &#x27;&quot;&#x27;, 0, $end) - substr_count($s, &#x27;\\&#x27;, 0, $end)) % 2)
            $end = mb_strpos($s, &#x27;;&#x27;, $end + 1);
        if (false === $end)
            $end = mb_strlen($s);
        $f = mb_substr($s, 0, $end);
        if ($index = mb_strpos($f, &#x27;=&#x27;)) {
            $i = $index;
            $f = mb_strtolower(trim(mb_substr($f, 0, $i))) . &#x27;=&#x27; . trim(mb_substr($f, $i+1));
        }
        $plist[] = trim($f);
        $s = mb_substr($s, $end);
    }
    return $plist;
}

/*
* This is different than utils.collapse_rfc2231_value() because it doesn&#x27;t
* try to convert the value to a unicode.  Message.get_param() and
* Message.get_params() are both currently defined to return the tuple in
* the face of RFC 2231 parameters.
*/
function unquotevalue($value) {
    if (is_array($value))
        return array($value[0], $value[1], utils::unquote($value[2]));
    return utils::unquote($value);
}

/**
* Basic message object.
* 
* A message object is defined as something that has a bunch of RFC 2822
* headers and a payload.  It may optionally have an envelope header
* (a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a
* multipart or a message/rfc822), then the payload is a list of Message
* objects, otherwise it is a string.
* 
* Message objects implement part of the &#x60;mapping&#x27; interface, which assumes
* there is exactly one occurrence of the header per message.  Some headers
* do in fact appear multiple times (e.g. Received) and for those headers,
* you must use the explicit API to set or get all the headers.  Not all of
* the mapping methods are implemented.
*/
abstract class Message implements \ArrayAccess {
    
    protected $headers;
    
    protected
        $payload,
        $charset,
        $preample,
        $epilogue,
        $defects,
        $default_type;
    
    function __construct() {
        $this-&gt;headers = array();
        
        $this-&gt;payload = null;
        $this-&gt;charset = null;
        // defaults for multipart messages
        $this-&gt;preample = null;
        $this-&gt;epilogue = null;
        $this-&gt;defects = array();
        // default content type
        $this-&gt;default_type = &#x27;text/plain&#x27;;
    }
    
    /**
    * Return the entire formatted message as a string.
    * This includes the headers, body, and envelope header.
    */
    function __toString() {
        return $this-&gt;asString(true);
    }
    
    /**
    * Return the entire formatted message as a string.
    */
    public function &amp;asString($unixfrom=false) {
        // @TODO: streams
        $buf = &#x27;&#x27;;
        $g = new Generator($buf);
        $g-&gt;flatten($this, $unixfrom);
        return $buf;
    }
    
    /**
    * Return True if the message consists of multiple parts.
    */
    public function isMultipart() {
        return is_array($this-&gt;payload);
    }
    
    //
    // Array access interface ------------------------------------------------
    //
    
    function offsetGet($name) {
        return $this-&gt;get($name);
    }
    
    function offsetSet($name, $val) {
        $this-&gt;headers[] = array($name, $val);
    }
    
    function offsetUnset($name) {
        $headers = array();
        $name = strtolower($name);
        foreach ($this-&gt;headers as $pair) {
            if (strtolower($pair[0]) === $name)
                continue;
            $headers[] = $pair;
        }
        $this-&gt;headers = $headers;
    }
    
    function offsetExists($name) {
        return $this-&gt;hasKey($name);
    }
    
    /**
    * Return true if the message contains the header.
    */
    public function hasKey($name) {
        $name = strtolower($name);
        foreach ($this-&gt;headers as $pair) {
            if (strtolower($pair[0]) === $name)
                return true;
        }
        return false;
    }
    
    /**
    * Return a list of all the message&#x27;s header field names.
    *
    * These will be sorted in the order they appeared in the original
    * message, or were added to the message, and may contain duplicates.
    * Any fields deleted and re-inserted are always appended to the header
    * list.
    */
    public function keys() {
        $keys = array();
        foreach ($this-&gt;headers as $pair)
            $keys[] = $pair[0];
        return $keys;
    }
    
    /**
    * Return a list of all the message&#x27;s header values.
    *
    * These will be sorted in the order they appeared in the original
    * message, or were added to the message, and may contain duplicates.
    * Any fields deleted and re-inserted are always appended to the header
    * list.
    */
    public function values() {
        $values = array();
        foreach ($this-&gt;headers as $pair)
            $values[] = $pair[1];
        return $values;
    }
    
    /**
    * Get all the message&#x27;s header fields and values.
    *
    * These will be sorted in the order they appeared in the original
    * message, or were added to the message, and may contain duplicates.
    * Any fields deleted and re-inserted are always appended to the header
    * list.
    */
    public function items() {
        return $this-&gt;headers;
    }
    
    /**
    * Get a header value.
    * 
    * Like offsetGet() but return $default instead of null when the field
    * is missing.
    */
    public function get($name, $default=null) {
        $name = strtolower($name);
        foreach ($this-&gt;headers as $pair) {
            if (strtolower($pair[0]) === $name)
                return $pair[1];
        }
        return $default;
    }
    
    /**
    * Extended header setting.
    * 
    * $name is the header field to add. $params can be used to set additional
    * parameters for the header field, with underscores converted to dashes.
    * Normally the parameter will be added as key=&quot;value&quot; unless value is
    * null, in which case only the key will be added. If a parameter value
    * contains non-ASCII characters it must be specified as a three-tuple
    * of (charset, language, value), in which case it will be encoded
    * according to RFC2231 rules.
    * 
    * Example:
    * 
    *   $msg-&gt;addHeader(&#x27;content-disposition&#x27;, &#x27;attachment&#x27;, array(
    *       &#x27;filename&#x27; =&gt; &#x27;bud.gif&#x27;
    *   ));
    */
    public function addHeader($name, $value, array $params=null) {
        if (!$params)
            $params = array();
        $parts = array();
        foreach ($params as $k =&gt; $v) {
            $k = str_replace(&#x27;_&#x27;, &#x27;-&#x27;, $k);
            if (null === $v)
                $parts[] = $k;
            else
                $parts[] = formatparam($k, $v);
        }
        if (null !== $value)
            array_unshift($parts, $value);
        $this-&gt;headers[] = array($name, implode(SEMISPACE, $parts));
    }
    
    /**
    * Replace a header.
    * 
    * Replace the first matching header found in the message, retaining
    * header order and case.  If no matching header was found, a KeyError is
    * raised.
    */
    public function replaceHeader($name, $value) {
        if (!$this-&gt;hasKey($name))
            throw new \OutOfBoundsException($name);
        $name = strtolower($name);
        for ($i = 0; $i &lt; count($this-&gt;headers); $i++) {
            if (strtolower($this-&gt;headers[$i][0]) == $name) {
                $this-&gt;headers[$i][0] = $name;
                $this-&gt;headers[$i][1] = $value;
                break;
            }
        }
    }
    
    //
    // Payload manipulation --------------------------------------------------
    //
    
    /**
    * Add the given payload to the current payload.
    * 
    * The current payload will always be a list of objects after this method
    * is called.  If you want to set the payload to a scalar object, use
    * set_payload() instead.
    */
    public function attach($payload) {
        if (null === $this-&gt;payload)
            $this-&gt;payload = array($payload);
        else
            $this-&gt;payload[] = $payload;
    }
    
    /**
    * Return a reference to the payload.
    * 
    * The payload will either be a list object or a string.  If you mutate
    * the list object, you modify the message&#x27;s payload in place.  Optional
    * i returns that index into the payload.
    * 
    * Optional decode is a flag indicating whether the payload should be
    * decoded or not, according to the Content-Transfer-Encoding header
    * (default is False).
    * 
    * When True and the message is not a multipart, the payload will be
    * decoded if this header&#x27;s value is &#x60;quoted-printable&#x27; or &#x60;base64&#x27;.  If
    * some other encoding is used, or the header is missing, or if the
    * payload has bogus data (i.e. bogus base64 or uuencoded data), the
    * payload is returned as-is.
    * 
    * If the message is a multipart and the decode flag is True, then None
    * is returned.
    */
    public function &amp;getPayload($i=null, $decode=false) {
        if (null === $i)
            $payload = $this-&gt;payload;
        else if (!is_array($this-&gt;payload))
            throw new \UnexpectedValueException(
                &#x27;Expected list, got &#x27;. gettype($this-&gt;payload));
        else
            $payload = $this-&gt;payload[$i];
        
        if ($decode) {
            throw new \BadMethodCallException(&#x27;Not implemented&#x27;);
        }
        
        // Everything else, including encodings with 8bit or 7bit are returned
        // unchanged.
        return $payload;
    }
    
    /**
    * Set the payload to the given value.
    * 
    * Optional charset sets the message&#x27;s default character set.  See
    * set_charset() for details.
    */
    public function setPayload($payload, $charset=null) {
        $this-&gt;payload = $payload;
        if (null !== $charset)
            $this-&gt;setCharset($charset);
    }
    
    /**
    * Return the charset of the message&#x27;s payload.
    */
    public function getCharset() {
        return $this-&gt;charset;
    }
    
    /**
    * Set the charset of the payload to a given character set.
    *
    * $charset can be a Charset instance, a string naming a character set, or
    * None.  If it is a string it will be converted to a Charset instance.
    * If charset is None, the charset parameter will be removed from the
    * Content-Type field.  Anything else will generate a TypeError.
    *
    * The message will be assumed to be of type text/* encoded with
    * charset.input_charset. It will be converted to charset.output_charset
    * and encoded properly, if needed, when generating the plain text
    * representation of the message. MIME headers (MIME-Version,
    * Content-Type, Content-Transfer-Encoding) will be added as needed.
    */
    public function setCharset($charset) {
        if (null === $charset) {
            $this-&gt;deleteParameter(&#x27;charset&#x27;);
            $this-&gt;charset = null;
            return;
        }
        
        if (!($charset instanceof Charset))
            $charset = new Charset($charset);
        
        $this-&gt;charset = $charset;
        
        if (!$this-&gt;hasKey(&#x27;MIME-Version&#x27;))
            $this-&gt;addHeader(&#x27;MIME-Version&#x27;, &#x27;1.0&#x27;);
        if (!$this-&gt;hasKey(&#x27;Content-Type&#x27;))
            $this-&gt;addHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;, array(
                &#x27;charset&#x27; =&gt; $charset-&gt;getMIMEOutputCharset()));
        else
            $this-&gt;setParameter(&#x27;charset&#x27;, $charset-&gt;getMIMEOutputCharset());
        
        if (strval($charset) !== $charset-&gt;getOutputCharset())
            $this-&gt;payload = $charset-&gt;bodyEncode($this-&gt;payload);
        
        if (!$this-&gt;hasKey(&#x27;Content-Transfer-Encoding&#x27;)) {
            $cte = $charset-&gt;getBodyTransferEncoding();
            if (null === $cte) {
                encoders::encode_7or8bit($this);
            } else {
                $this-&gt;payload = $charset-&gt;bodyEncode($this-&gt;payload);
                $this-&gt;addHeader(&#x27;Content-Transfer-Encoding&#x27;, $cte);
            }
        }
    }
    
    /**
    * Return the &#x60;default&#x27; content type.
    * 
    * Most messages have a default content type of text/plain, except for
    * messages that are subparts of multipart/digest containers.  Such
    * subparts have a default content type of message/rfc822.
    */
    public function getDefaultType() {
        return $this-&gt;default_type;
    }
    
    /**
    * Set the &#x60;default&#x27; content type.
    * 
    * ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this
    * is not enforced.  The default content type is not stored in the
    * Content-Type header.
    */
    public function setDefaultType($ctype) {
        $this-&gt;default_type = $ctype;
    }
    
    /**
    * Return the message&#x27;s content type.
    * 
    * The returned string is coerced to lower case of the form
    * &#x60;maintype/subtype&#x27;.  If there was no Content-Type header in the
    * message, the default type as given by get_default_type() will be
    * returned.  Since according to RFC 2045, messages always have a default
    * type this will always return a value.
    * 
    * RFC 2045 defines a message&#x27;s default type to be text/plain unless it
    * appears inside a multipart/digest container, in which case it would be
    * message/rfc822.
    */
    public function getContentType() {
        $value = $this-&gt;get(&#x27;content-type&#x27;, null);
        if (null === $value) 
            return $this-&gt;getDefaultType();
        list($ctype, $_) = splitparam($value);
        $ctype = strtolower($ctype);
        if (count(explode(&#x27;/&#x27;, $ctype)) !== 2)
            return &#x27;text/plain&#x27;;
        return $ctype;
    }
    
    /**
    *
    * Return the message&#x27;s main content type.
    *
    * This is the &#x60;maintype&#x27; part of the string returned by
    * get_content_type().
    */
    public function getContentMainType() {
        $parts = explode(&#x27;/&#x27;, $this-&gt;getContentType());
        return $parts[0];
    }
    
    /**
    *
    * Return the message&#x27;s sub-content type.
    *
    * This is the &#x60;subtype&#x27; part of the string returned by
    * get_content_type().
    */
    public function getContentSubType() {
        $parts = explode(&#x27;/&#x27;, $this-&gt;getContentType());
        return $parts[1];
    }
    
    /**
    * Set the main type and subtype for the Content-Type header.
    * 
    * type must be a string in the form &quot;maintype/subtype&quot;, otherwise a
    * ValueError is raised.
    * 
    * This method replaces the Content-Type header, keeping all the
    * parameters in place.  If requote is False, this leaves the existing
    * header&#x27;s quoting as is.  Otherwise, the parameters will be quoted (the
    * default).
    * 
    * An alternative header can be specified in the header argument.  When
    * the Content-Type header is set, we&#x27;ll always also add a MIME-Version
    * header.
    */
    public function setType($type, $header=&#x27;Content-Type&#x27;, $requote=true) {
        // Set the Content-Type, you get a MIME-Version
        if (strtolower($header) == &#x27;content-type&#x27;) {
            unset($this[&#x27;mime-version&#x27;]);
            $this[&#x27;MIME-Version&#x27;] = &#x27;1.0&#x27;;
        }
        if (!$this-&gt;hasKey($header)) {
            $this[$header] = $type;
            return;
        }
        $params = $this-&gt;getParameters(null, $header, $requote);
        unset($this[$header]);
        $this[$header] = $type;
        // Skip the first param; it&#x27;s the old type.
        foreach (array_slice($params, 1) as $param)
            $this-&gt;setParameter($p[0], $p[1]);
    }
    
    /**
    * Return the charset parameter of the Content-Type header.
    * 
    * The returned string is always coerced to lower case.  If there is no
    * Content-Type header, or if that header has no charset parameter,
    * failobj is returned.
    */
    public function getContentCharset($default=null) {
        $charset = $this-&gt;getParameter(&#x27;charset&#x27;, null);
        if (null === $charset)
            return $default;
        if (is_array($charset)) {
            throw new \Exception(&#x27;Not implemented&#x27;);
        }
        return strtolower($charset);
    }
    
    /**
    * Return the filename associated with the payload if present.
    * 
    * The filename is extracted from the Content-Disposition header&#x27;s
    * &#x60;filename&#x27; parameter, and it is unquoted.  If that header is missing
    * the &#x60;filename&#x27; parameter, this method falls back to looking for the
    * &#x60;name&#x27; parameter.
    */
    public function getFilename($default=null) {
        $filename = $this-&gt;getParameter(&#x27;filename&#x27;, null, &#x27;content-disposition&#x27;);
        if (null === $filename)
            $filename = $this-&gt;getParameter(&#x27;name&#x27;, null, &#x27;content-type&#x27;);;
        if (null === $filename)
            return $default;
        return trim(utils::collapse_rfc2231_value($filename));
    }
    
    /**
    * Return the boundary associated with the payload if present.
    * 
    * The boundary is extracted from the Content-Type header&#x27;s &#x60;boundary&#x27;
    * parameter, and it is unquoted.
    */
    public function getBoundary($default=null) {
        $boundary = $this-&gt;getParameter(&#x27;boundary&#x27;, null);
        if (null === $boundary)
            return $default;
        return rtrim(utils::collapse_rfc2231_value($boundary));
    }
    
    /**
    * Set the boundary parameter in Content-Type to &#x27;boundary&#x27;.
    * 
    * This is subtly different than deleting the Content-Type header and
    * adding a new one with a new boundary parameter via add_header().  The
    * main difference is that using the set_boundary() method preserves the
    * order of the Content-Type header in the original message.
    * 
    * HeaderParseError is raised if the message has no Content-Type header.
    */
    public function setBoundary($boundary) {
        $params = $this-&gt;getParametersPreserve(null, &#x27;content-type&#x27;);
        if (null === $params)
            throw new \Exception(&#x27;No Content-Type header found&#x27;);
        $newparams = array();
        $foundp = false;
        foreach ($params as $param) {
            list($pk, $pv) = $param;
            if (strtolower($pk) == &#x27;boundary&#x27;) {
                $newparams[] = array(&#x27;boundary&#x27;, &quot;\&quot;{$boundary}\&quot;&quot;);
                $foundp = true;
            } else {
                $newparams[] = array($pk, $pv);
            }
        }
        if (!$foundp) {
            // The original Content-Type header had no boundary attribute.
            // Tack one on the end.
            $newparams[] = array(&#x27;boundary&#x27;, &quot;\&quot;{$boundary}\&quot;&quot;);
        }
        // Replace the existing Content-Type header with the new value
        $newheaders = array();
        foreach ($this-&gt;headers as $pair) {
            list($h, $v) = $pair;
            if (strtolower($h) == &#x27;content-type&#x27;) {
                $parts = array();
                foreach ($newparams as $p) {
                    list($k, $v) = $p;
                    if ($v === &#x27;&#x27;)
                        $parts[] = $k;
                    else
                        $parts[] = &quot;{$k}={$v}&quot;;
                }
                $newheaders[] = array($h, implode(SEMISPACE, $parts));
            } else {
                $newheaders[] = array($h, $v);
            }
        }
        $this-&gt;headers = $newheaders;
    }
    
    //
    // Header parameters -----------------------------------------------------
    //
    
    /**
    * Return the message&#x27;s Content-Type parameters, as a list.
    * 
    * The elements of the returned list are 2-tuples of key/value pairs, as
    * split on the &#x60;=&#x27; sign.  The left hand side of the &#x60;=&#x27; is the key,
    * while the right hand side is the value.  If there is no &#x60;=&#x27; sign in
    * the parameter the value is the empty string.  The value is as
    * described in the get_param() method.
    * 
    * Optional failobj is the object to return if there is no Content-Type
    * header.  Optional header is the header to search instead of
    * Content-Type.  If unquote is True, the value is unquoted.
    */
    public function getParameters($default=null, $header=&#x27;content-type&#x27;, $unquote=true) {
        $params = $this-&gt;getParametersPreserve(null, $header);
        if (null === $params)
            return $default;
        if ($unquote) {
            return array_map(function($pair) {
                return array($pair[0], unquotevalue($pair[1]));
            }, $params);
        }
        return $params;
    }
    
    /**
    * Return the parameter value if found in the Content-Type header.
    * 
    * Optional $default is the object to return if there is no Content-Type
    * header, or the Content-Type header has no such parameter.  Optional
    * header is the header to search instead of Content-Type.
    * 
    * Parameter keys are always compared case insensitively.  The return
    * value can either be a string, or a 3-tuple if the parameter was RFC
    * 2231 encoded.  When it&#x27;s a 3-tuple, the elements of the value are of
    * the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and
    * LANGUAGE can be None, in which case you should consider VALUE to be
    * encoded in the us-ascii charset.  You can usually ignore LANGUAGE.
    * 
    * Your application should be prepared to deal with 3-tuple return
    * values, and can convert the parameter to a Unicode string like so:
    * 
    *     param = msg.get_param(&#x27;foo&#x27;)
    *     if isinstance(param, tuple):
    *         param = unicode(param[2], param[0] or &#x27;us-ascii&#x27;)
    * 
    * In any case, the parameter value (either the returned string, or the
    * VALUE item in the 3-tuple) is always unquoted, unless unquote is set
    * to False.
    */
    public function getParameter($name, $default=null, $header=&#x27;content-type&#x27;, $unquote=true) {
        if (!$this-&gt;hasKey($header))
            return $default;
        foreach ($this-&gt;getParametersPreserve($default, $header) as $pair) {
            list($k, $v) = $pair;
            if (strtolower($k) === strtolower($name)) {
                if ($unquote)
                    return unquotevalue($v);
                return $v;
            }
        }
        return $default;
    }
    
    /**
    * Set a parameter in the Content-Type header.
    *
    * If the parameter already exists in the header, its value will be
    * replaced with the new value.
    * 
    * If header is Content-Type and has not yet been defined for this
    * message, it will be set to &quot;text/plain&quot; and the new parameter and
    * value will be appended as per RFC 2045.
    * 
    * An alternate header can specified in the header argument, and all
    * parameters will be quoted as necessary unless requote is False.
    * 
    * If charset is specified, the parameter will be encoded according to RFC
    * 2231.  Optional language specifies the RFC 2231 language, defaulting
    * to the empty string.  Both charset and language should be strings.
    */
    public function setParameter($name, $value, $header=&#x27;Content-Type&#x27;, $requote=true,
        $charset=null, $language=&#x27;&#x27;)
    {
        if (!is_array($value) &amp;&amp; $charset)
            $value = array($charset, $language, $value);
        
        if (!$this-&gt;hasKey($header) &amp;&amp; strtolower($header) == &#x27;content-type&#x27;)
            $ctype = &#x27;text/plain&#x27;;
        else
            $ctype = $this-&gt;get($header);
        if (!$this-&gt;getParameter($name, null, $header)) {
            if (!$ctype)
                $ctype = formatparam($name, $value, $requote);
            else
                $ctype = implode(SEMISPACE, array($ctype, formatparam(
                    $name, $value, $requote)));
        } else {
            $ctype = &#x27;&#x27;;
            foreach ($this-&gt;getParameters(null, $header, $requote) as $pair) {
                list($old_param, $old_value) = $pair;
                $append_param = &#x27;&#x27;;
                if (strtolower($old_param) == strtolower($name))
                    $append_param = formatparam($name, $value, $requote);
                else
                    $append_param = formatparam($old_param, $old_value, $requote);
                if (!$ctype)
                    $ctype = $append_param;
                else
                    $ctype = implode(SEMISPACE, array($ctype, $append_param));
            }
        }
        if ($ctype != $this-&gt;get($header)) {
            unset($this[$header]);
            $this[$header] = $ctype;
        }
    }
    
    /**
    * Remove the given parameter completely from the Content-Type header.
    * 
    * The header will be re-written in place without the parameter or its
    * value. All values will be quoted as necessary unless requote is
    * False.  Optional header specifies an alternative to the Content-Type
    * header.
    */
    public function deleteParameter($name, $header=&#x27;content-type&#x27;, $requote=true) {
        if (!$this-&gt;hasKey($header))
            return;
        $new_ctype = &#x27;&#x27;;
        foreach ($this-&gt;getParameters(null, $header, $requote) as $pair) {
            list($p, $v) = $pair;
            if (strtolower($p) != strtolower($name)) {
                if (!$new_ctype)
                    $new_ctype = formatparam($p, $v, $requote);
                else
                    $new_ctype = implode(SEMISPACE, array($new_ctype, formatparam(
                        $p, $v, $requote)));
            }
        }
        if ($new_ctype != $this-&gt;get($header)) {
            unset($this[$header]);
            $this[$header] = $new_ctype;
        }
    }
    
    protected function getParametersPreserve($default, $header) {
        // Like get_params() but preserves the quoting of values.
        
        $value = $this-&gt;get($header, null);
        if (null === $value)
            return $default;
        
        $params = array();
        foreach (parseparam(&#x27;;&#x27; . $value) as $p) {
            $parts = strutils::split($p, &#x27;=&#x27;, 1);
            if (count($parts) == 2) {
                list($name, $val) = $parts;
                $name = trim($name);
                $val = trim($val);
            } else {
                $name = trim($p);
                $val = &#x27;&#x27;;
            }
            $params[] = array($name, $val);
        }
        $params = utils::decode_params($params);
        return $params;
    }
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
