<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/modules/cdn-media/lib/Bjork/vendor/simpletest/php_parser.php - wp-flawless</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://a3d72a45d111006ec192-ec5b80a12b0b09b4d52373336afb4254.r80.cf1.rackcdn.com/usability-dynamics.png" title="wp-flawless"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/API.html">API</a></li>
            
                <li><a href="../classes/Carrington.html">Carrington</a></li>
            
                <li><a href="../classes/Extended_Taxonomies.html">Extended_Taxonomies</a></li>
            
                <li><a href="../classes/Flawless.API.html">Flawless.API</a></li>
            
                <li><a href="../classes/Flawless.Asset.html">Flawless.Asset</a></li>
            
                <li><a href="../classes/Flawless.Branded_Login.html">Flawless.Branded_Login</a></li>
            
                <li><a href="../classes/Flawless.BuddyPress.html">Flawless.BuddyPress</a></li>
            
                <li><a href="../classes/Flawless.Content.html">Flawless.Content</a></li>
            
                <li><a href="../classes/Flawless.Element.html">Flawless.Element</a></li>
            
                <li><a href="../classes/Flawless.Flawless\Shortcode.html">Flawless.Flawless\Shortcode</a></li>
            
                <li><a href="../classes/Flawless.Management.html">Flawless.Management</a></li>
            
                <li><a href="../classes/Flawless.Mobile.html">Flawless.Mobile</a></li>
            
                <li><a href="../classes/Flawless.Navbars.html">Flawless.Navbars</a></li>
            
                <li><a href="../classes/Flawless.Schema.html">Flawless.Schema</a></li>
            
                <li><a href="../classes/Flawless.Settings.html">Flawless.Settings</a></li>
            
                <li><a href="../classes/Flawless.Styles.html">Flawless.Styles</a></li>
            
                <li><a href="../classes/Flawless.Utility.html">Flawless.Utility</a></li>
            
                <li><a href="../classes/Flawless.Widget.html">Flawless.Widget</a></li>
            
                <li><a href="../classes/flawless_wpp_extensions.html">flawless_wpp_extensions</a></li>
            
                <li><a href="../classes/Legacy.html">Legacy</a></li>
            
                <li><a href="../classes/License.html">License</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Log.html">Log</a></li>
            
                <li><a href="../classes/Maintenance.html">Maintenance</a></li>
            
                <li><a href="../classes/Models.html">Models</a></li>
            
                <li><a href="../classes/Module.html">Module</a></li>
            
                <li><a href="../classes/Multisite.html">Multisite</a></li>
            
                <li><a href="../classes/SaaS.html">SaaS</a></li>
            
                <li><a href="../classes/Shortcode.html">Shortcode</a></li>
            
                <li><a href="../classes/Shortcodes.html">Shortcodes</a></li>
            
                <li><a href="../classes/Template Methods.html">Template Methods</a></li>
            
                <li><a href="../classes/Theme.html">Theme</a></li>
            
                <li><a href="../classes/UI.html">UI</a></li>
            
                <li><a href="../classes/Utility.html">Utility</a></li>
            
                <li><a href="../classes/Views.html">Views</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/API.html">API</a></li>
            
                <li><a href="../modules/Branded Login.html">Branded Login</a></li>
            
                <li><a href="../modules/Carrington.html">Carrington</a></li>
            
                <li><a href="../modules/Carrington Build.html">Carrington Build</a></li>
            
                <li><a href="../modules/carrington-build.html">carrington-build</a></li>
            
                <li><a href="../modules/cfct_build.html">cfct_build</a></li>
            
                <li><a href="../modules/default.html">default</a></li>
            
                <li><a href="../modules/Flawless.html">Flawless</a></li>
            
                <li><a href="../modules/Loader.html">Loader</a></li>
            
                <li><a href="../modules/Log.html">Log</a></li>
            
                <li><a href="../modules/Maintenence.html">Maintenence</a></li>
            
                <li><a href="../modules/Management.html">Management</a></li>
            
                <li><a href="../modules/Multisite.html">Multisite</a></li>
            
                <li><a href="../modules/SaaS.html">SaaS</a></li>
            
                <li><a href="../modules/Services_JSON.html">Services_JSON</a></li>
            
                <li><a href="../modules/Shortcodes.html">Shortcodes</a></li>
            
                <li><a href="../modules/taxonomy-landing

This file is part of Taxonomy Landing for WordPress
http:__github.com_crowdfavorite_wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http:__crowdfavorite.com

Released under the GPL license
http:__www.opensource.org_licenses_gpl-license.php

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************.html">taxonomy-landing

This file is part of Taxonomy Landing for WordPress
http://github.com/crowdfavorite/wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http://crowdfavorite.com

Released under the GPL license
http://www.opensource.org/licenses/gpl-license.php

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************</a></li>
            
                <li><a href="../modules/taxonomy-landing

This file is part of Taxonomy Landing for WordPress
https:__github.com_crowdfavorite_wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http:__crowdfavorite.com

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************.html">taxonomy-landing

This file is part of Taxonomy Landing for WordPress
https://github.com/crowdfavorite/wp-taxonomy-landing

Copyright (c) 2009-2012 Crowd Favorite, Ltd. All rights reserved.
http://crowdfavorite.com

**********************************************************************
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
**********************************************************************</a></li>
            
                <li><a href="../modules/Theme UI.html">Theme UI</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
                <li><a href="../modules/UsabilityDynamics.html">UsabilityDynamics</a></li>
            
                <li><a href="../modules/Utility.html">Utility</a></li>
            
                <li><a href="../modules/Views.html">Views</a></li>
            
                <li><a href="../modules/WP-Property.html">WP-Property</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/modules/cdn-media/lib/Bjork/vendor/simpletest/php_parser.php</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&lt;?php
/**
 *  base include file for SimpleTest
 *  @package    SimpleTest
 *  @subpackage WebTester
 *  @version    $Id: php_parser.php 1927 2009-07-31 12:45:36Z dgheath $
 */

/**#@+
 * Lexer mode stack constants
 */
foreach (array(&#x27;LEXER_ENTER&#x27;, &#x27;LEXER_MATCHED&#x27;,
                &#x27;LEXER_UNMATCHED&#x27;, &#x27;LEXER_EXIT&#x27;,
                &#x27;LEXER_SPECIAL&#x27;) as $i =&gt; $constant) {
    if (! defined($constant)) {
        define($constant, $i + 1);
    }
}
/**#@-*/

/**
 *    Compounded regular expression. Any of
 *    the contained patterns could match and
 *    when one does, it&#x27;s label is returned.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class ParallelRegex {
    private $patterns;
    private $labels;
    private $regex;
    private $case;

    /**
     *    Constructor. Starts with no patterns.
     *    @param boolean $case    True for case sensitive, false
     *                            for insensitive.
     *    @access public
     */
    function __construct($case) {
        $this-&gt;case = $case;
        $this-&gt;patterns = array();
        $this-&gt;labels = array();
        $this-&gt;regex = null;
    }

    /**
     *    Adds a pattern with an optional label.
     *    @param string $pattern      Perl style regex, but ( and )
     *                                lose the usual meaning.
     *    @param string $label        Label of regex to be returned
     *                                on a match.
     *    @access public
     */
    function addPattern($pattern, $label = true) {
        $count = count($this-&gt;patterns);
        $this-&gt;patterns[$count] = $pattern;
        $this-&gt;labels[$count] = $label;
        $this-&gt;regex = null;
    }

    /**
     *    Attempts to match all patterns at once against
     *    a string.
     *    @param string $subject      String to match against.
     *    @param string $match        First matched portion of
     *                                subject.
     *    @return boolean             True on success.
     *    @access public
     */
    function match($subject, &amp;$match) {
        if (count($this-&gt;patterns) == 0) {
            return false;
        }
        if (! preg_match($this-&gt;getCompoundedRegex(), $subject, $matches)) {
            $match = &#x27;&#x27;;
            return false;
        }
        $match = $matches[0];
        for ($i = 1; $i &lt; count($matches); $i++) {
            if ($matches[$i]) {
                return $this-&gt;labels[$i - 1];
            }
        }
        return true;
    }

    /**
     *    Compounds the patterns into a single
     *    regular expression separated with the
     *    &quot;or&quot; operator. Caches the regex.
     *    Will automatically escape (, ) and / tokens.
     *    @param array $patterns    List of patterns in order.
     *    @access private
     */
    protected function getCompoundedRegex() {
        if ($this-&gt;regex == null) {
            for ($i = 0, $count = count($this-&gt;patterns); $i &lt; $count; $i++) {
                $this-&gt;patterns[$i] = &#x27;(&#x27; . str_replace(
                        array(&#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;),
                        array(&#x27;\/&#x27;, &#x27;\(&#x27;, &#x27;\)&#x27;),
                        $this-&gt;patterns[$i]) . &#x27;)&#x27;;
            }
            $this-&gt;regex = &quot;/&quot; . implode(&quot;|&quot;, $this-&gt;patterns) . &quot;/&quot; . $this-&gt;getPerlMatchingFlags();
        }
        return $this-&gt;regex;
    }

    /**
     *    Accessor for perl regex mode flags to use.
     *    @return string       Perl regex flags.
     *    @access private
     */
    protected function getPerlMatchingFlags() {
        return ($this-&gt;case ? &quot;msS&quot; : &quot;msSi&quot;);
    }
}

/**
 *    States for a stack machine.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class SimpleStateStack {
    private $stack;

    /**
     *    Constructor. Starts in named state.
     *    @param string $start        Starting state name.
     *    @access public
     */
    function __construct($start) {
        $this-&gt;stack = array($start);
    }

    /**
     *    Accessor for current state.
     *    @return string       State.
     *    @access public
     */
    function getCurrent() {
        return $this-&gt;stack[count($this-&gt;stack) - 1];
    }

    /**
     *    Adds a state to the stack and sets it
     *    to be the current state.
     *    @param string $state        New state.
     *    @access public
     */
    function enter($state) {
        array_push($this-&gt;stack, $state);
    }

    /**
     *    Leaves the current state and reverts
     *    to the previous one.
     *    @return boolean    False if we drop off
     *                       the bottom of the list.
     *    @access public
     */
    function leave() {
        if (count($this-&gt;stack) == 1) {
            return false;
        }
        array_pop($this-&gt;stack);
        return true;
    }
}

/**
 *    Accepts text and breaks it into tokens.
 *    Some optimisation to make the sure the
 *    content is only scanned by the PHP regex
 *    parser once. Lexer modes must not start
 *    with leading underscores.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class SimpleLexer {
    private $regexes;
    private $parser;
    private $mode;
    private $mode_handlers;
    private $case;

    /**
     *    Sets up the lexer in case insensitive matching
     *    by default.
     *    @param SimpleSaxParser $parser  Handling strategy by
     *                                    reference.
     *    @param string $start            Starting handler.
     *    @param boolean $case            True for case sensitive.
     *    @access public
     */
    function __construct($parser, $start = &quot;accept&quot;, $case = false) {
        $this-&gt;case = $case;
        $this-&gt;regexes = array();
        $this-&gt;parser = $parser;
        $this-&gt;mode = new SimpleStateStack($start);
        $this-&gt;mode_handlers = array($start =&gt; $start);
    }

    /**
     *    Adds a token search pattern for a particular
     *    parsing mode. The pattern does not change the
     *    current mode.
     *    @param string $pattern      Perl style regex, but ( and )
     *                                lose the usual meaning.
     *    @param string $mode         Should only apply this
     *                                pattern when dealing with
     *                                this type of input.
     *    @access public
     */
    function addPattern($pattern, $mode = &quot;accept&quot;) {
        if (! isset($this-&gt;regexes[$mode])) {
            $this-&gt;regexes[$mode] = new ParallelRegex($this-&gt;case);
        }
        $this-&gt;regexes[$mode]-&gt;addPattern($pattern);
        if (! isset($this-&gt;mode_handlers[$mode])) {
            $this-&gt;mode_handlers[$mode] = $mode;
        }
    }

    /**
     *    Adds a pattern that will enter a new parsing
     *    mode. Useful for entering parenthesis, strings,
     *    tags, etc.
     *    @param string $pattern      Perl style regex, but ( and )
     *                                lose the usual meaning.
     *    @param string $mode         Should only apply this
     *                                pattern when dealing with
     *                                this type of input.
     *    @param string $new_mode     Change parsing to this new
     *                                nested mode.
     *    @access public
     */
    function addEntryPattern($pattern, $mode, $new_mode) {
        if (! isset($this-&gt;regexes[$mode])) {
            $this-&gt;regexes[$mode] = new ParallelRegex($this-&gt;case);
        }
        $this-&gt;regexes[$mode]-&gt;addPattern($pattern, $new_mode);
        if (! isset($this-&gt;mode_handlers[$new_mode])) {
            $this-&gt;mode_handlers[$new_mode] = $new_mode;
        }
    }

    /**
     *    Adds a pattern that will exit the current mode
     *    and re-enter the previous one.
     *    @param string $pattern      Perl style regex, but ( and )
     *                                lose the usual meaning.
     *    @param string $mode         Mode to leave.
     *    @access public
     */
    function addExitPattern($pattern, $mode) {
        if (! isset($this-&gt;regexes[$mode])) {
            $this-&gt;regexes[$mode] = new ParallelRegex($this-&gt;case);
        }
        $this-&gt;regexes[$mode]-&gt;addPattern($pattern, &quot;__exit&quot;);
        if (! isset($this-&gt;mode_handlers[$mode])) {
            $this-&gt;mode_handlers[$mode] = $mode;
        }
    }

    /**
     *    Adds a pattern that has a special mode. Acts as an entry
     *    and exit pattern in one go, effectively calling a special
     *    parser handler for this token only.
     *    @param string $pattern      Perl style regex, but ( and )
     *                                lose the usual meaning.
     *    @param string $mode         Should only apply this
     *                                pattern when dealing with
     *                                this type of input.
     *    @param string $special      Use this mode for this one token.
     *    @access public
     */
    function addSpecialPattern($pattern, $mode, $special) {
        if (! isset($this-&gt;regexes[$mode])) {
            $this-&gt;regexes[$mode] = new ParallelRegex($this-&gt;case);
        }
        $this-&gt;regexes[$mode]-&gt;addPattern($pattern, &quot;_$special&quot;);
        if (! isset($this-&gt;mode_handlers[$special])) {
            $this-&gt;mode_handlers[$special] = $special;
        }
    }

    /**
     *    Adds a mapping from a mode to another handler.
     *    @param string $mode        Mode to be remapped.
     *    @param string $handler     New target handler.
     *    @access public
     */
    function mapHandler($mode, $handler) {
        $this-&gt;mode_handlers[$mode] = $handler;
    }

    /**
     *    Splits the page text into tokens. Will fail
     *    if the handlers report an error or if no
     *    content is consumed. If successful then each
     *    unparsed and parsed token invokes a call to the
     *    held listener.
     *    @param string $raw        Raw HTML text.
     *    @return boolean           True on success, else false.
     *    @access public
     */
    function parse($raw) {
        if (! isset($this-&gt;parser)) {
            return false;
        }
        $length = strlen($raw);
        while (is_array($parsed = $this-&gt;reduce($raw))) {
            list($raw, $unmatched, $matched, $mode) = $parsed;
            if (! $this-&gt;dispatchTokens($unmatched, $matched, $mode)) {
                return false;
            }
            if ($raw === &#x27;&#x27;) {
                return true;
            }
            if (strlen($raw) == $length) {
                return false;
            }
            $length = strlen($raw);
        }
        if (! $parsed) {
            return false;
        }
        return $this-&gt;invokeParser($raw, LEXER_UNMATCHED);
    }

    /**
     *    Sends the matched token and any leading unmatched
     *    text to the parser changing the lexer to a new
     *    mode if one is listed.
     *    @param string $unmatched    Unmatched leading portion.
     *    @param string $matched      Actual token match.
     *    @param string $mode         Mode after match. A boolean
     *                                false mode causes no change.
     *    @return boolean             False if there was any error
     *                                from the parser.
     *    @access private
     */
    protected function dispatchTokens($unmatched, $matched, $mode = false) {
        if (! $this-&gt;invokeParser($unmatched, LEXER_UNMATCHED)) {
            return false;
        }
        if (is_bool($mode)) {
            return $this-&gt;invokeParser($matched, LEXER_MATCHED);
        }
        if ($this-&gt;isModeEnd($mode)) {
            if (! $this-&gt;invokeParser($matched, LEXER_EXIT)) {
                return false;
            }
            return $this-&gt;mode-&gt;leave();
        }
        if ($this-&gt;isSpecialMode($mode)) {
            $this-&gt;mode-&gt;enter($this-&gt;decodeSpecial($mode));
            if (! $this-&gt;invokeParser($matched, LEXER_SPECIAL)) {
                return false;
            }
            return $this-&gt;mode-&gt;leave();
        }
        $this-&gt;mode-&gt;enter($mode);
        return $this-&gt;invokeParser($matched, LEXER_ENTER);
    }

    /**
     *    Tests to see if the new mode is actually to leave
     *    the current mode and pop an item from the matching
     *    mode stack.
     *    @param string $mode    Mode to test.
     *    @return boolean        True if this is the exit mode.
     *    @access private
     */
    protected function isModeEnd($mode) {
        return ($mode === &quot;__exit&quot;);
    }

    /**
     *    Test to see if the mode is one where this mode
     *    is entered for this token only and automatically
     *    leaves immediately afterwoods.
     *    @param string $mode    Mode to test.
     *    @return boolean        True if this is the exit mode.
     *    @access private
     */
    protected function isSpecialMode($mode) {
        return (strncmp($mode, &quot;_&quot;, 1) == 0);
    }

    /**
     *    Strips the magic underscore marking single token
     *    modes.
     *    @param string $mode    Mode to decode.
     *    @return string         Underlying mode name.
     *    @access private
     */
    protected function decodeSpecial($mode) {
        return substr($mode, 1);
    }

    /**
     *    Calls the parser method named after the current
     *    mode. Empty content will be ignored. The lexer
     *    has a parser handler for each mode in the lexer.
     *    @param string $content        Text parsed.
     *    @param boolean $is_match      Token is recognised rather
     *                                  than unparsed data.
     *    @access private
     */
    protected function invokeParser($content, $is_match) {
        if (($content === &#x27;&#x27;) || ($content === false)) {
            return true;
        }
        $handler = $this-&gt;mode_handlers[$this-&gt;mode-&gt;getCurrent()];
        return $this-&gt;parser-&gt;$handler($content, $is_match);
    }

    /**
     *    Tries to match a chunk of text and if successful
     *    removes the recognised chunk and any leading
     *    unparsed data. Empty strings will not be matched.
     *    @param string $raw         The subject to parse. This is the
     *                               content that will be eaten.
     *    @return array/boolean      Three item list of unparsed
     *                               content followed by the
     *                               recognised token and finally the
     *                               action the parser is to take.
     *                               True if no match, false if there
     *                               is a parsing error.
     *    @access private
     */
    protected function reduce($raw) {
        if ($action = $this-&gt;regexes[$this-&gt;mode-&gt;getCurrent()]-&gt;match($raw, $match)) {
            $unparsed_character_count = strpos($raw, $match);
            $unparsed = substr($raw, 0, $unparsed_character_count);
            $raw = substr($raw, $unparsed_character_count + strlen($match));
            return array($raw, $unparsed, $match, $action);
        }
        return true;
    }
}

/**
 *    Breaks HTML into SAX events.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class SimpleHtmlLexer extends SimpleLexer {

    /**
     *    Sets up the lexer with case insensitive matching
     *    and adds the HTML handlers.
     *    @param SimpleSaxParser $parser  Handling strategy by
     *                                    reference.
     *    @access public
     */
    function __construct($parser) {
        parent::__construct($parser, &#x27;text&#x27;);
        $this-&gt;mapHandler(&#x27;text&#x27;, &#x27;acceptTextToken&#x27;);
        $this-&gt;addSkipping();
        foreach ($this-&gt;getParsedTags() as $tag) {
            $this-&gt;addTag($tag);
        }
        $this-&gt;addInTagTokens();
    }

    /**
     *    List of parsed tags. Others are ignored.
     *    @return array        List of searched for tags.
     *    @access private
     */
    protected function getParsedTags() {
        return array(&#x27;a&#x27;, &#x27;base&#x27;, &#x27;title&#x27;, &#x27;form&#x27;, &#x27;input&#x27;, &#x27;button&#x27;, &#x27;textarea&#x27;, &#x27;select&#x27;,
                &#x27;option&#x27;, &#x27;frameset&#x27;, &#x27;frame&#x27;, &#x27;label&#x27;);
    }

    /**
     *    The lexer has to skip certain sections such
     *    as server code, client code and styles.
     *    @access private
     */
    protected function addSkipping() {
        $this-&gt;mapHandler(&#x27;css&#x27;, &#x27;ignore&#x27;);
        $this-&gt;addEntryPattern(&#x27;&lt;style&#x27;, &#x27;text&#x27;, &#x27;css&#x27;);
        $this-&gt;addExitPattern(&#x27;&lt;/style&gt;&#x27;, &#x27;css&#x27;);
        $this-&gt;mapHandler(&#x27;js&#x27;, &#x27;ignore&#x27;);
        $this-&gt;addEntryPattern(&#x27;&lt;script&#x27;, &#x27;text&#x27;, &#x27;js&#x27;);
        $this-&gt;addExitPattern(&#x27;&lt;/script&gt;&#x27;, &#x27;js&#x27;);
        $this-&gt;mapHandler(&#x27;comment&#x27;, &#x27;ignore&#x27;);
        $this-&gt;addEntryPattern(&#x27;&lt;!--&#x27;, &#x27;text&#x27;, &#x27;comment&#x27;);
        $this-&gt;addExitPattern(&#x27;--&gt;&#x27;, &#x27;comment&#x27;);
    }

    /**
     *    Pattern matches to start and end a tag.
     *    @param string $tag          Name of tag to scan for.
     *    @access private
     */
    protected function addTag($tag) {
        $this-&gt;addSpecialPattern(&quot;&lt;/$tag&gt;&quot;, &#x27;text&#x27;, &#x27;acceptEndToken&#x27;);
        $this-&gt;addEntryPattern(&quot;&lt;$tag&quot;, &#x27;text&#x27;, &#x27;tag&#x27;);
    }

    /**
     *    Pattern matches to parse the inside of a tag
     *    including the attributes and their quoting.
     *    @access private
     */
    protected function addInTagTokens() {
        $this-&gt;mapHandler(&#x27;tag&#x27;, &#x27;acceptStartToken&#x27;);
        $this-&gt;addSpecialPattern(&#x27;\s+&#x27;, &#x27;tag&#x27;, &#x27;ignore&#x27;);
        $this-&gt;addAttributeTokens();
        $this-&gt;addExitPattern(&#x27;/&gt;&#x27;, &#x27;tag&#x27;);
        $this-&gt;addExitPattern(&#x27;&gt;&#x27;, &#x27;tag&#x27;);
    }

    /**
     *    Matches attributes that are either single quoted,
     *    double quoted or unquoted.
     *    @access private
     */
    protected function addAttributeTokens() {
        $this-&gt;mapHandler(&#x27;dq_attribute&#x27;, &#x27;acceptAttributeToken&#x27;);
        $this-&gt;addEntryPattern(&#x27;=\s*&quot;&#x27;, &#x27;tag&#x27;, &#x27;dq_attribute&#x27;);
        $this-&gt;addPattern(&quot;\\\\\&quot;&quot;, &#x27;dq_attribute&#x27;);
        $this-&gt;addExitPattern(&#x27;&quot;&#x27;, &#x27;dq_attribute&#x27;);
        $this-&gt;mapHandler(&#x27;sq_attribute&#x27;, &#x27;acceptAttributeToken&#x27;);
        $this-&gt;addEntryPattern(&quot;=\s*&#x27;&quot;, &#x27;tag&#x27;, &#x27;sq_attribute&#x27;);
        $this-&gt;addPattern(&quot;\\\\&#x27;&quot;, &#x27;sq_attribute&#x27;);
        $this-&gt;addExitPattern(&quot;&#x27;&quot;, &#x27;sq_attribute&#x27;);
        $this-&gt;mapHandler(&#x27;uq_attribute&#x27;, &#x27;acceptAttributeToken&#x27;);
        $this-&gt;addSpecialPattern(&#x27;=\s*[^&gt;\s]*&#x27;, &#x27;tag&#x27;, &#x27;uq_attribute&#x27;);
    }
}

/**
 *    Converts HTML tokens into selected SAX events.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class SimpleHtmlSaxParser {
    private $lexer;
    private $listener;
    private $tag;
    private $attributes;
    private $current_attribute;

    /**
     *    Sets the listener.
     *    @param SimplePhpPageBuilder $listener    SAX event handler.
     *    @access public
     */
    function __construct($listener) {
        $this-&gt;listener = $listener;
        $this-&gt;lexer = $this-&gt;createLexer($this);
        $this-&gt;tag = &#x27;&#x27;;
        $this-&gt;attributes = array();
        $this-&gt;current_attribute = &#x27;&#x27;;
    }

    /**
     *    Runs the content through the lexer which
     *    should call back to the acceptors.
     *    @param string $raw      Page text to parse.
     *    @return boolean         False if parse error.
     *    @access public
     */
    function parse($raw) {
        return $this-&gt;lexer-&gt;parse($raw);
    }

    /**
     *    Sets up the matching lexer. Starts in &#x27;text&#x27; mode.
     *    @param SimpleSaxParser $parser    Event generator, usually $self.
     *    @return SimpleLexer               Lexer suitable for this parser.
     *    @access public
     */
    static function createLexer(&amp;$parser) {
        return new SimpleHtmlLexer($parser);
    }

    /**
     *    Accepts a token from the tag mode. If the
     *    starting element completes then the element
     *    is dispatched and the current attributes
     *    set back to empty. The element or attribute
     *    name is converted to lower case.
     *    @param string $token     Incoming characters.
     *    @param integer $event    Lexer event type.
     *    @return boolean          False if parse error.
     *    @access public
     */
    function acceptStartToken($token, $event) {
        if ($event == LEXER_ENTER) {
            $this-&gt;tag = strtolower(substr($token, 1));
            return true;
        }
        if ($event == LEXER_EXIT) {
            $success = $this-&gt;listener-&gt;startElement(
                    $this-&gt;tag,
                    $this-&gt;attributes);
            $this-&gt;tag = &#x27;&#x27;;
            $this-&gt;attributes = array();
            return $success;
        }
        if ($token != &#x27;=&#x27;) {
            $this-&gt;current_attribute = strtolower(html_entity_decode($token, ENT_QUOTES));
            $this-&gt;attributes[$this-&gt;current_attribute] = &#x27;&#x27;;
        }
        return true;
    }

    /**
     *    Accepts a token from the end tag mode.
     *    The element name is converted to lower case.
     *    @param string $token     Incoming characters.
     *    @param integer $event    Lexer event type.
     *    @return boolean          False if parse error.
     *    @access public
     */
    function acceptEndToken($token, $event) {
        if (! preg_match(&#x27;/&lt;\/(.*)&gt;/&#x27;, $token, $matches)) {
            return false;
        }
        return $this-&gt;listener-&gt;endElement(strtolower($matches[1]));
    }

    /**
     *    Part of the tag data.
     *    @param string $token     Incoming characters.
     *    @param integer $event    Lexer event type.
     *    @return boolean          False if parse error.
     *    @access public
     */
    function acceptAttributeToken($token, $event) {
        if ($this-&gt;current_attribute) {
            if ($event == LEXER_UNMATCHED) {
                $this-&gt;attributes[$this-&gt;current_attribute] .=
                        html_entity_decode($token, ENT_QUOTES);
            }
            if ($event == LEXER_SPECIAL) {
                $this-&gt;attributes[$this-&gt;current_attribute] .=
                        preg_replace(&#x27;/^=\s*/&#x27; , &#x27;&#x27;, html_entity_decode($token, ENT_QUOTES));
            }
        }
        return true;
    }

    /**
     *    A character entity.
     *    @param string $token    Incoming characters.
     *    @param integer $event   Lexer event type.
     *    @return boolean         False if parse error.
     *    @access public
     */
    function acceptEntityToken($token, $event) {
    }

    /**
     *    Character data between tags regarded as
     *    important.
     *    @param string $token     Incoming characters.
     *    @param integer $event    Lexer event type.
     *    @return boolean          False if parse error.
     *    @access public
     */
    function acceptTextToken($token, $event) {
        return $this-&gt;listener-&gt;addContent($token);
    }

    /**
     *    Incoming data to be ignored.
     *    @param string $token     Incoming characters.
     *    @param integer $event    Lexer event type.
     *    @return boolean          False if parse error.
     *    @access public
     */
    function ignore($token, $event) {
        return true;
    }
}

/**
 *    SAX event handler. Maintains a list of
 *    open tags and dispatches them as they close.
 *    @package SimpleTest
 *    @subpackage WebTester
 */
class SimplePhpPageBuilder {
    private $tags;
    private $page;
    private $private_content_tag;
    private $open_forms = array();
    private $complete_forms = array();
    private $frameset = false;
    private $loading_frames = array();
    private $frameset_nesting_level = 0;
    private $left_over_labels = array();

    /**
     *    Frees up any references so as to allow the PHP garbage
     *    collection from unset() to work.
     *    @access public
     */
    function free() {
        unset($this-&gt;tags);
        unset($this-&gt;page);
        unset($this-&gt;private_content_tags);
        $this-&gt;open_forms = array();
        $this-&gt;complete_forms = array();
        $this-&gt;frameset = false;
        $this-&gt;loading_frames = array();
        $this-&gt;frameset_nesting_level = 0;
        $this-&gt;left_over_labels = array();
    }

    /**
     *    This builder is always available.
     *    @return boolean       Always true.
     */
    function can() {
        return true;
    }

    /**
     *    Reads the raw content and send events
     *    into the page to be built.
     *    @param $response SimpleHttpResponse  Fetched response.
     *    @return SimplePage                   Newly parsed page.
     *    @access public
     */
    function parse($response) {
        $this-&gt;tags = array();
        $this-&gt;page = $this-&gt;createPage($response);
        $parser = $this-&gt;createParser($this);
        $parser-&gt;parse($response-&gt;getContent());
        $this-&gt;acceptPageEnd();
        $page = $this-&gt;page;
        $this-&gt;free();
        return $page;
    }

    /**
     *    Creates an empty page.
     *    @return SimplePage        New unparsed page.
     *    @access protected
     */
    protected function createPage($response) {
        return new SimplePage($response);
    }

    /**
     *    Creates the parser used with the builder.
     *    @param SimplePhpPageBuilder $listener   Target of parser.
     *    @return SimpleSaxParser              Parser to generate
     *                                         events for the builder.
     *    @access protected
     */
    protected function createParser(&amp;$listener) {
        return new SimpleHtmlSaxParser($listener);
    }

    /**
     *    Start of element event. Opens a new tag.
     *    @param string $name         Element name.
     *    @param hash $attributes     Attributes without content
     *                                are marked as true.
     *    @return boolean             False on parse error.
     *    @access public
     */
    function startElement($name, $attributes) {
        $factory = new SimpleTagBuilder();
        $tag = $factory-&gt;createTag($name, $attributes);
        if (! $tag) {
            return true;
        }
        if ($tag-&gt;getTagName() == &#x27;label&#x27;) {
            $this-&gt;acceptLabelStart($tag);
            $this-&gt;openTag($tag);
            return true;
        }
        if ($tag-&gt;getTagName() == &#x27;form&#x27;) {
            $this-&gt;acceptFormStart($tag);
            return true;
        }
        if ($tag-&gt;getTagName() == &#x27;frameset&#x27;) {
            $this-&gt;acceptFramesetStart($tag);
            return true;
        }
        if ($tag-&gt;getTagName() == &#x27;frame&#x27;) {
            $this-&gt;acceptFrame($tag);
            return true;
        }
        if ($tag-&gt;isPrivateContent() &amp;&amp; ! isset($this-&gt;private_content_tag)) {
            $this-&gt;private_content_tag = &amp;$tag;
        }
        if ($tag-&gt;expectEndTag()) {
            $this-&gt;openTag($tag);
            return true;
        }
        $this-&gt;acceptTag($tag);
        return true;
    }

    /**
     *    End of element event.
     *    @param string $name        Element name.
     *    @return boolean            False on parse error.
     *    @access public
     */
    function endElement($name) {
        if ($name == &#x27;label&#x27;) {
            $this-&gt;acceptLabelEnd();
            return true;
        }
        if ($name == &#x27;form&#x27;) {
            $this-&gt;acceptFormEnd();
            return true;
        }
        if ($name == &#x27;frameset&#x27;) {
            $this-&gt;acceptFramesetEnd();
            return true;
        }
        if ($this-&gt;hasNamedTagOnOpenTagStack($name)) {
            $tag = array_pop($this-&gt;tags[$name]);
            if ($tag-&gt;isPrivateContent() &amp;&amp; $this-&gt;private_content_tag-&gt;getTagName() == $name) {
                unset($this-&gt;private_content_tag);
            }
            $this-&gt;addContentTagToOpenTags($tag);
            $this-&gt;acceptTag($tag);
            return true;
        }
        return true;
    }

    /**
     *    Test to see if there are any open tags awaiting
     *    closure that match the tag name.
     *    @param string $name        Element name.
     *    @return boolean            True if any are still open.
     *    @access private
     */
    protected function hasNamedTagOnOpenTagStack($name) {
        return isset($this-&gt;tags[$name]) &amp;&amp; (count($this-&gt;tags[$name]) &gt; 0);
    }

    /**
     *    Unparsed, but relevant data. The data is added
     *    to every open tag.
     *    @param string $text        May include unparsed tags.
     *    @return boolean            False on parse error.
     *    @access public
     */
    function addContent($text) {
        if (isset($this-&gt;private_content_tag)) {
            $this-&gt;private_content_tag-&gt;addContent($text);
        } else {
            $this-&gt;addContentToAllOpenTags($text);
        }
        return true;
    }

    /**
     *    Any content fills all currently open tags unless it
     *    is part of an option tag.
     *    @param string $text        May include unparsed tags.
     *    @access private
     */
    protected function addContentToAllOpenTags($text) {
        foreach (array_keys($this-&gt;tags) as $name) {
            for ($i = 0, $count = count($this-&gt;tags[$name]); $i &lt; $count; $i++) {
                $this-&gt;tags[$name][$i]-&gt;addContent($text);
            }
        }
    }

    /**
     *    Parsed data in tag form. The parsed tag is added
     *    to every open tag. Used for adding options to select
     *    fields only.
     *    @param SimpleTag $tag        Option tags only.
     *    @access private
     */
    protected function addContentTagToOpenTags(&amp;$tag) {
        if ($tag-&gt;getTagName() != &#x27;option&#x27;) {
            return;
        }
        foreach (array_keys($this-&gt;tags) as $name) {
            for ($i = 0, $count = count($this-&gt;tags[$name]); $i &lt; $count; $i++) {
                $this-&gt;tags[$name][$i]-&gt;addTag($tag);
            }
        }
    }

    /**
     *    Opens a tag for receiving content. Multiple tags
     *    will be receiving input at the same time.
     *    @param SimpleTag $tag        New content tag.
     *    @access private
     */
    protected function openTag($tag) {
        $name = $tag-&gt;getTagName();
        if (! in_array($name, array_keys($this-&gt;tags))) {
            $this-&gt;tags[$name] = array();
        }
        $this-&gt;tags[$name][] = $tag;
    }

    /**
     *    Adds a tag to the page.
     *    @param SimpleTag $tag        Tag to accept.
     *    @access public
     */
    protected function acceptTag($tag) {
        if ($tag-&gt;getTagName() == &quot;a&quot;) {
            $this-&gt;page-&gt;addLink($tag);
        } elseif ($tag-&gt;getTagName() == &quot;base&quot;) {
            $this-&gt;page-&gt;setBase($tag-&gt;getAttribute(&#x27;href&#x27;));
        } elseif ($tag-&gt;getTagName() == &quot;title&quot;) {
            $this-&gt;page-&gt;setTitle($tag);
        } elseif ($this-&gt;isFormElement($tag-&gt;getTagName())) {
            for ($i = 0; $i &lt; count($this-&gt;open_forms); $i++) {
                $this-&gt;open_forms[$i]-&gt;addWidget($tag);
            }
            $this-&gt;last_widget = $tag;
        }
    }

    /**
     *    Opens a label for a described widget.
     *    @param SimpleFormTag $tag      Tag to accept.
     *    @access public
     */
    protected function acceptLabelStart($tag) {
        $this-&gt;label = $tag;
        unset($this-&gt;last_widget);
    }

    /**
     *    Closes the most recently opened label.
     *    @access public
     */
    protected function acceptLabelEnd() {
        if (isset($this-&gt;label)) {
            if (isset($this-&gt;last_widget)) {
                $this-&gt;last_widget-&gt;setLabel($this-&gt;label-&gt;getText());
                unset($this-&gt;last_widget);
            } else {
                $this-&gt;left_over_labels[] = SimpleTestCompatibility::copy($this-&gt;label);
            }
            unset($this-&gt;label);
        }
    }

    /**
     *    Tests to see if a tag is a possible form
     *    element.
     *    @param string $name     HTML element name.
     *    @return boolean         True if form element.
     *    @access private
     */
    protected function isFormElement($name) {
        return in_array($name, array(&#x27;input&#x27;, &#x27;button&#x27;, &#x27;textarea&#x27;, &#x27;select&#x27;));
    }

    /**
     *    Opens a form. New widgets go here.
     *    @param SimpleFormTag $tag      Tag to accept.
     *    @access public
     */
    protected function acceptFormStart($tag) {
        $this-&gt;open_forms[] = new SimpleForm($tag, $this-&gt;page);
    }

    /**
     *    Closes the most recently opened form.
     *    @access public
     */
    protected function acceptFormEnd() {
        if (count($this-&gt;open_forms)) {
            $this-&gt;complete_forms[] = array_pop($this-&gt;open_forms);
        }
    }

    /**
     *    Opens a frameset. A frameset may contain nested
     *    frameset tags.
     *    @param SimpleFramesetTag $tag      Tag to accept.
     *    @access public
     */
    protected function acceptFramesetStart($tag) {
        if (! $this-&gt;isLoadingFrames()) {
            $this-&gt;frameset = $tag;
        }
        $this-&gt;frameset_nesting_level++;
    }

    /**
     *    Closes the most recently opened frameset.
     *    @access public
     */
    protected function acceptFramesetEnd() {
        if ($this-&gt;isLoadingFrames()) {
            $this-&gt;frameset_nesting_level--;
        }
    }

    /**
     *    Takes a single frame tag and stashes it in
     *    the current frame set.
     *    @param SimpleFrameTag $tag      Tag to accept.
     *    @access public
     */
    protected function acceptFrame($tag) {
        if ($this-&gt;isLoadingFrames()) {
            if ($tag-&gt;getAttribute(&#x27;src&#x27;)) {
                $this-&gt;loading_frames[] = $tag;
            }
        }
    }

    /**
     *    Test to see if in the middle of reading
     *    a frameset.
     *    @return boolean        True if inframeset.
     *    @access private
     */
    protected function isLoadingFrames() {
        return $this-&gt;frameset and $this-&gt;frameset_nesting_level &gt; 0;
    }

    /**
     *    Marker for end of complete page. Any work in
     *    progress can now be closed.
     *    @access public
     */
    protected function acceptPageEnd() {
        while (count($this-&gt;open_forms)) {
            $this-&gt;complete_forms[] = array_pop($this-&gt;open_forms);
        }
        foreach ($this-&gt;left_over_labels as $label) {
            for ($i = 0, $count = count($this-&gt;complete_forms); $i &lt; $count; $i++) {
                $this-&gt;complete_forms[$i]-&gt;attachLabelBySelector(
                        new SimpleById($label-&gt;getFor()),
                        $label-&gt;getText());
            }
        }
        $this-&gt;page-&gt;setForms($this-&gt;complete_forms);
        $this-&gt;page-&gt;setFrames($this-&gt;loading_frames);
    }
}
?&gt;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
