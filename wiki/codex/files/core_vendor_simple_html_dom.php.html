<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/vendor/simple_html_dom.php - Flawless</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://a3d72a45d111006ec192-ec5b80a12b0b09b4d52373336afb4254.r80.cf1.rackcdn.com/usability-dynamics.png" title="Flawless"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/flawless_wpp_extensions.html">flawless_wpp_extensions</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Shortcodes.html">Shortcodes</a></li>
            
                <li><a href="../classes/Template Functions.html">Template Functions</a></li>
            
                <li><a href="../classes/Theme UI.html">Theme UI</a></li>
            
                <li><a href="../classes/UD_API.html">UD_API</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Core Assets.html">Core Assets</a></li>
            
                <li><a href="../modules/Flawless.html">Flawless</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/vendor/simple_html_dom.php</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&lt;?php
/**
 * Website: http://sourceforge.net/projects/simplehtmldom/
 * Acknowledge: Jose Solorzano (https://sourceforge.net/projects/php-html/)
 * Contributions by:
 *     Yousuke Kumakura (Attribute filters)
 *     Vadim Voituk (Negative indexes supports of &quot;find&quot; method)
 *     Antcs (Constructor with automatically load contents either text or file/url)
 *
 * all affected sections have comments starting with &quot;PaperG&quot;
 *
 * Paperg - Added case insensitive testing of the value of the selector.
 * Paperg - Added tag_start for the starting index of tags - NOTE: This works but not accurately.
 *  This tag_start gets counted AFTER \r\n have been crushed out, and after the remove_noice calls so it will not reflect the REAL position of the tag in the source,
 *  it will almost always be smaller by some amount.
 *  We use this to determine how far into the file the tag in question is.  This &quot;percentage will never be accurate as the $dom-&gt;size is the &quot;real&quot; number of bytes the dom was created from.
 *  but for most purposes, it&#x27;s a really good estimation.
 * Paperg - Added the forceTagsClosed to the dom constructor.  Forcing tags closed is great for malformed html, but it CAN lead to parsing errors.
 * Allow the user to tell us how much they trust the html.
 * Paperg add the text and plaintext to the selectors for the find syntax.  plaintext implies text in the innertext of a node.  text implies that the tag is a text node.
 * This allows for us to find tags based on the text they contain.
 * Create find_ancestor_tag to see if a tag is - at any level - inside of another specific tag.
 * Paperg: added parse_charset so that we know about the character set of the source document.
 *  NOTE:  If the user&#x27;s system has a routine called get_last_retrieve_url_contents_content_type availalbe, we will assume it&#x27;s returning the content-type header from the
 *  last transfer or curl_exec, and we will parse that and use it in preference to any other method of charset detection.
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @author S.C. Chen &lt;me578022@gmail.com&gt;
 * @author John Schlick
 * @author Rus Carroll
 * @version 1.11 ($Rev: 184 $)
 * @package PlaceLocalInclude
 * @subpackage simple_html_dom
 */

/**
 * All of the Defines for the classes below.
 * @author S.C. Chen &lt;me578022@gmail.com&gt;
 */
define(&#x27;HDOM_TYPE_ELEMENT&#x27;, 1);
define(&#x27;HDOM_TYPE_COMMENT&#x27;, 2);
define(&#x27;HDOM_TYPE_TEXT&#x27;,    3);
define(&#x27;HDOM_TYPE_ENDTAG&#x27;,  4);
define(&#x27;HDOM_TYPE_ROOT&#x27;,    5);
define(&#x27;HDOM_TYPE_UNKNOWN&#x27;, 6);
define(&#x27;HDOM_QUOTE_DOUBLE&#x27;, 0);
define(&#x27;HDOM_QUOTE_SINGLE&#x27;, 1);
define(&#x27;HDOM_QUOTE_NO&#x27;,     3);
define(&#x27;HDOM_INFO_BEGIN&#x27;,   0);
define(&#x27;HDOM_INFO_END&#x27;,     1);
define(&#x27;HDOM_INFO_QUOTE&#x27;,   2);
define(&#x27;HDOM_INFO_SPACE&#x27;,   3);
define(&#x27;HDOM_INFO_TEXT&#x27;,    4);
define(&#x27;HDOM_INFO_INNER&#x27;,   5);
define(&#x27;HDOM_INFO_OUTER&#x27;,   6);
define(&#x27;HDOM_INFO_ENDSPACE&#x27;,7);
define(&#x27;DEFAULT_TARGET_CHARSET&#x27;, &#x27;UTF-8&#x27;);
define(&#x27;DEFAULT_BR_TEXT&#x27;, &quot;\r\n&quot;);
// helper functions
// -----------------------------------------------------------------------------
// get html dom from file
// $maxlen is defined in the code as PHP_STREAM_COPY_ALL which is defined as -1.
function file_get_html($url, $use_include_path = false, $context=null, $offset = -1, $maxLen=-1, $lowercase = true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT)
{
    // We DO force the tags to be terminated.
    $dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $defaultBRText);
    // For sourceforge users: uncomment the next line and comment the retreive_url_contents line 2 lines down if it is not already done.
    $contents = file_get_contents($url, $use_include_path, $context, $offset);
    // Paperg - use our own mechanism for getting the contents as we want to control the timeout.
//    $contents = retrieve_url_contents($url);
    if (empty($contents))
    {
        return false;
    }
    // The second parameter can force the selectors to all be lowercase.
    $dom-&gt;load($contents, $lowercase, $stripRN);
    return $dom;
}

// get html dom from string
function str_get_html($str, $lowercase=true, $forceTagsClosed=true, $target_charset = DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT)
{
    $dom = new simple_html_dom(null, $lowercase, $forceTagsClosed, $target_charset, $defaultBRText);
    if (empty($str))
    {
        $dom-&gt;clear();
        return false;
    }
    $dom-&gt;load($str, $lowercase, $stripRN);
    return $dom;
}

// dump html dom tree
function dump_html_tree($node, $show_attr=true, $deep=0)
{
    $node-&gt;dump($node);
}

/**
 * simple html dom node
 * PaperG - added ability for &quot;find&quot; routine to lowercase the value of the selector.
 * PaperG - added $tag_start to track the start position of the tag in the total byte index
 *
 * @package PlaceLocalInclude
 */
class simple_html_dom_node {
    public $nodetype = HDOM_TYPE_TEXT;
    public $tag = &#x27;text&#x27;;
    public $attr = array();
    public $children = array();
    public $nodes = array();
    public $parent = null;
    public $_ = array();
    public $tag_start = 0;
    private $dom = null;

    function __construct($dom)
    {
        $this-&gt;dom = $dom;
        $dom-&gt;nodes[] = $this;
    }

    function __destruct()
    {
        $this-&gt;clear();
    }

    function __toString()
    {
        return $this-&gt;outertext();
    }

    // clean up memory due to php5 circular references memory leak...
    function clear()
    {
        $this-&gt;dom = null;
        $this-&gt;nodes = null;
        $this-&gt;parent = null;
        $this-&gt;children = null;
    }

    // dump node&#x27;s tree
    function dump($show_attr=true, $deep=0)
    {
        $lead = str_repeat(&#x27;    &#x27;, $deep);

        echo $lead.$this-&gt;tag;
        if ($show_attr &amp;&amp; count($this-&gt;attr)&gt;0)
        {
            echo &#x27;(&#x27;;
            foreach ($this-&gt;attr as $k=&gt;$v)
                echo &quot;[$k]=&gt;\&quot;&quot;.$this-&gt;$k.&#x27;&quot;, &#x27;;
            echo &#x27;)&#x27;;
        }
        echo &quot;\n&quot;;

        foreach ($this-&gt;nodes as $c)
            $c-&gt;dump($show_attr, $deep+1);
    }


    // Debugging function to dump a single dom node with a bunch of information about it.
    function dump_node()
    {
        echo $this-&gt;tag;
        if (count($this-&gt;attr)&gt;0)
        {
            echo &#x27;(&#x27;;
            foreach ($this-&gt;attr as $k=&gt;$v)
            {
                echo &quot;[$k]=&gt;\&quot;&quot;.$this-&gt;$k.&#x27;&quot;, &#x27;;
            }
            echo &#x27;)&#x27;;
        }
        if (count($this-&gt;attr)&gt;0)
        {
            echo &#x27; $_ (&#x27;;
            foreach ($this-&gt;_ as $k=&gt;$v)
            {
                if (is_array($v))
                {
                    echo &quot;[$k]=&gt;(&quot;;
                    foreach ($v as $k2=&gt;$v2)
                    {
                        echo &quot;[$k2]=&gt;\&quot;&quot;.$v2.&#x27;&quot;, &#x27;;
                    }
                    echo &quot;)&quot;;
                } else {
                    echo &quot;[$k]=&gt;\&quot;&quot;.$v.&#x27;&quot;, &#x27;;
                }
            }
            echo &quot;)&quot;;
        }

        if (isset($this-&gt;text))
        {
            echo &quot; text: (&quot; . $this-&gt;text . &quot;)&quot;;
        }

        echo &quot; children: &quot; . count($this-&gt;children);
        echo &quot; nodes: &quot; . count($this-&gt;nodes);
        echo &quot; tag_start: &quot; . $this-&gt;tag_start;
        echo &quot;\n&quot;;

    }

    // returns the parent of node
    function parent()
    {
        return $this-&gt;parent;
    }

    // returns children of node
    function children($idx=-1)
    {
        if ($idx===-1) return $this-&gt;children;
        if (isset($this-&gt;children[$idx])) return $this-&gt;children[$idx];
        return null;
    }

    // returns the first child of node
    function first_child()
    {
        if (count($this-&gt;children)&gt;0) return $this-&gt;children[0];
        return null;
    }

    // returns the last child of node
    function last_child()
    {
        if (($count=count($this-&gt;children))&gt;0) return $this-&gt;children[$count-1];
        return null;
    }

    // returns the next sibling of node
    function next_sibling()
    {
        if ($this-&gt;parent===null) return null;
        $idx = 0;
        $count = count($this-&gt;parent-&gt;children);
        while ($idx&lt;$count &amp;&amp; $this!==$this-&gt;parent-&gt;children[$idx])
            ++$idx;
        if (++$idx&gt;=$count) return null;
        return $this-&gt;parent-&gt;children[$idx];
    }

    // returns the previous sibling of node
    function prev_sibling()
    {
        if ($this-&gt;parent===null) return null;
        $idx = 0;
        $count = count($this-&gt;parent-&gt;children);
        while ($idx&lt;$count &amp;&amp; $this!==$this-&gt;parent-&gt;children[$idx])
            ++$idx;
        if (--$idx&lt;0) return null;
        return $this-&gt;parent-&gt;children[$idx];
    }

    // function to locate a specific ancestor tag in the path to the root.
    function find_ancestor_tag($tag)
    {
        global $debugObject;
        if (is_object($debugObject))
        {
            $debugObject-&gt;debugLogEntry(1);
        }

        // Start by including ourselves in the comparison.
        $returnDom = $this;

        while (!is_null($returnDom))
        {
            if (is_object($debugObject))
            {
                $debugObject-&gt;debugLog(2, &quot;Current tag is: &quot; . $returnDom-&gt;tag);
            }

            if ($returnDom-&gt;tag == $tag)
            {
                break;
            }
            $returnDom = $returnDom-&gt;parent;
        }
        return $returnDom;
    }

    // get dom node&#x27;s inner html
    function innertext()
    {
        if (isset($this-&gt;_[HDOM_INFO_INNER])) return $this-&gt;_[HDOM_INFO_INNER];
        if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);

        $ret = &#x27;&#x27;;
        foreach ($this-&gt;nodes as $n)
            $ret .= $n-&gt;outertext();
        return $ret;
    }

    // get dom node&#x27;s outer text (with tag)
    function outertext()
    {
        global $debugObject;
        if (is_object($debugObject))
        {
            $text = &#x27;&#x27;;
            if ($this-&gt;tag == &#x27;text&#x27;)
            {
                if (!empty($this-&gt;text))
                {
                    $text = &quot; with text: &quot; . $this-&gt;text;
                }
            }
            $debugObject-&gt;debugLog(1, &#x27;Innertext of tag: &#x27; . $this-&gt;tag . $text);
        }

        if ($this-&gt;tag===&#x27;root&#x27;) return $this-&gt;innertext();

        // trigger callback
        if ($this-&gt;dom &amp;&amp; $this-&gt;dom-&gt;callback!==null)
        {
            call_user_func_array($this-&gt;dom-&gt;callback, array($this));
        }

        if (isset($this-&gt;_[HDOM_INFO_OUTER])) return $this-&gt;_[HDOM_INFO_OUTER];
        if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);

        // render begin tag
        if ($this-&gt;dom &amp;&amp; $this-&gt;dom-&gt;nodes[$this-&gt;_[HDOM_INFO_BEGIN]])
        {
            $ret = $this-&gt;dom-&gt;nodes[$this-&gt;_[HDOM_INFO_BEGIN]]-&gt;makeup();
        } else {
            $ret = &quot;&quot;;
        }

        // render inner text
        if (isset($this-&gt;_[HDOM_INFO_INNER]))
        {
            // If it&#x27;s a br tag...  don&#x27;t return the HDOM_INNER_INFO that we may or may not have added.
            if ($this-&gt;tag != &quot;br&quot;)
            {
                $ret .= $this-&gt;_[HDOM_INFO_INNER];
            }
        } else {
            if ($this-&gt;nodes)
            {
                foreach ($this-&gt;nodes as $n)
                {
                    $ret .= $this-&gt;convert_text($n-&gt;outertext());
                }
            }
        }

        // render end tag
        if (isset($this-&gt;_[HDOM_INFO_END]) &amp;&amp; $this-&gt;_[HDOM_INFO_END]!=0)
            $ret .= &#x27;&lt;/&#x27;.$this-&gt;tag.&#x27;&gt;&#x27;;
        return $ret;
    }

    // get dom node&#x27;s plain text
    function text()
    {
        if (isset($this-&gt;_[HDOM_INFO_INNER])) return $this-&gt;_[HDOM_INFO_INNER];
        switch ($this-&gt;nodetype)
        {
            case HDOM_TYPE_TEXT: return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);
            case HDOM_TYPE_COMMENT: return &#x27;&#x27;;
            case HDOM_TYPE_UNKNOWN: return &#x27;&#x27;;
        }
        if (strcasecmp($this-&gt;tag, &#x27;script&#x27;)===0) return &#x27;&#x27;;
        if (strcasecmp($this-&gt;tag, &#x27;style&#x27;)===0) return &#x27;&#x27;;

        $ret = &#x27;&#x27;;
        // In rare cases, (always node type 1 or HDOM_TYPE_ELEMENT - observed for some span tags, and some p tags) $this-&gt;nodes is set to NULL.
        // NOTE: This indicates that there is a problem where it&#x27;s set to NULL without a clear happening.
        // WHY is this happening?
        if (!is_null($this-&gt;nodes))
        {
            foreach ($this-&gt;nodes as $n)
            {
                $ret .= $this-&gt;convert_text($n-&gt;text());
            }
        }
        return $ret;
    }

    function xmltext()
    {
        $ret = $this-&gt;innertext();
        $ret = str_ireplace(&#x27;&lt;![CDATA[&#x27;, &#x27;&#x27;, $ret);
        $ret = str_replace(&#x27;]]&gt;&#x27;, &#x27;&#x27;, $ret);
        return $ret;
    }

    // build node&#x27;s text with tag
    function makeup()
    {
        // text, comment, unknown
        if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;dom-&gt;restore_noise($this-&gt;_[HDOM_INFO_TEXT]);

        $ret = &#x27;&lt;&#x27;.$this-&gt;tag;
        $i = -1;

        foreach ($this-&gt;attr as $key=&gt;$val)
        {
            ++$i;

            // skip removed attribute
            if ($val===null || $val===false)
                continue;

            $ret .= $this-&gt;_[HDOM_INFO_SPACE][$i][0];
            //no value attr: nowrap, checked selected...
            if ($val===true)
                $ret .= $key;
            else {
                switch ($this-&gt;_[HDOM_INFO_QUOTE][$i])
                {
                    case HDOM_QUOTE_DOUBLE: $quote = &#x27;&quot;&#x27;; break;
                    case HDOM_QUOTE_SINGLE: $quote = &#x27;\&#x27;&#x27;; break;
                    default: $quote = &#x27;&#x27;;
                }
                $ret .= $key.$this-&gt;_[HDOM_INFO_SPACE][$i][1].&#x27;=&#x27;.$this-&gt;_[HDOM_INFO_SPACE][$i][2].$quote.$val.$quote;
            }
        }
        $ret = $this-&gt;dom-&gt;restore_noise($ret);
        return $ret . $this-&gt;_[HDOM_INFO_ENDSPACE] . &#x27;&gt;&#x27;;
    }

    // find elements by css selector
    //PaperG - added ability for find to lowercase the value of the selector.
    function find($selector, $idx=null, $lowercase=false)
    {
        $selectors = $this-&gt;parse_selector($selector);
        if (($count=count($selectors))===0) return array();
        $found_keys = array();

        // find each selector
        for ($c=0; $c&lt;$count; ++$c)
        {
            // The change on the below line was documented on the sourceforge code tracker id 2788009
            // used to be: if (($levle=count($selectors[0]))===0) return array();
            if (($levle=count($selectors[$c]))===0) return array();
            if (!isset($this-&gt;_[HDOM_INFO_BEGIN])) return array();

            $head = array($this-&gt;_[HDOM_INFO_BEGIN]=&gt;1);

            // handle descendant selectors, no recursive!
            for ($l=0; $l&lt;$levle; ++$l)
            {
                $ret = array();
                foreach ($head as $k=&gt;$v)
                {
                    $n = ($k===-1) ? $this-&gt;dom-&gt;root : $this-&gt;dom-&gt;nodes[$k];
                    //PaperG - Pass this optional parameter on to the seek function.
                    $n-&gt;seek($selectors[$c][$l], $ret, $lowercase);
                }
                $head = $ret;
            }

            foreach ($head as $k=&gt;$v)
            {
                if (!isset($found_keys[$k]))
                    $found_keys[$k] = 1;
            }
        }

        // sort keys
        ksort($found_keys);

        $found = array();
        foreach ($found_keys as $k=&gt;$v)
            $found[] = $this-&gt;dom-&gt;nodes[$k];

        // return nth-element or array
        if (is_null($idx)) return $found;
        else if ($idx&lt;0) $idx = count($found) + $idx;
        return (isset($found[$idx])) ? $found[$idx] : null;
    }

    // seek for given conditions
    // PaperG - added parameter to allow for case insensitive testing of the value of a selector.
    protected function seek($selector, &amp;$ret, $lowercase=false)
    {
        global $debugObject;
        if (is_object($debugObject))
        {
            $debugObject-&gt;debugLogEntry(1);
        }

        list($tag, $key, $val, $exp, $no_key) = $selector;

        // xpath index
        if ($tag &amp;&amp; $key &amp;&amp; is_numeric($key))
        {
            $count = 0;
            foreach ($this-&gt;children as $c)
            {
                if ($tag===&#x27;*&#x27; || $tag===$c-&gt;tag) {
                    if (++$count==$key) {
                        $ret[$c-&gt;_[HDOM_INFO_BEGIN]] = 1;
                        return;
                    }
                }
            }
            return;
        }

        $end = (!empty($this-&gt;_[HDOM_INFO_END])) ? $this-&gt;_[HDOM_INFO_END] : 0;
        if ($end==0) {
            $parent = $this-&gt;parent;
            while (!isset($parent-&gt;_[HDOM_INFO_END]) &amp;&amp; $parent!==null) {
                $end -= 1;
                $parent = $parent-&gt;parent;
            }
            $end += $parent-&gt;_[HDOM_INFO_END];
        }

        for ($i=$this-&gt;_[HDOM_INFO_BEGIN]+1; $i&lt;$end; ++$i) {
            $node = $this-&gt;dom-&gt;nodes[$i];

            $pass = true;

            if ($tag===&#x27;*&#x27; &amp;&amp; !$key) {
                if (in_array($node, $this-&gt;children, true))
                    $ret[$i] = 1;
                continue;
            }

            // compare tag
            if ($tag &amp;&amp; $tag!=$node-&gt;tag &amp;&amp; $tag!==&#x27;*&#x27;) {$pass=false;}
            // compare key
            if ($pass &amp;&amp; $key) {
                if ($no_key) {
                    if (isset($node-&gt;attr[$key])) $pass=false;
                } else {
                    if (($key != &quot;plaintext&quot;) &amp;&amp; !isset($node-&gt;attr[$key])) $pass=false;
                }
            }
            // compare value
            if ($pass &amp;&amp; $key &amp;&amp; $val  &amp;&amp; $val!==&#x27;*&#x27;) {
                // If they have told us that this is a &quot;plaintext&quot; search then we want the plaintext of the node - right?
                if ($key == &quot;plaintext&quot;) {
                    // $node-&gt;plaintext actually returns $node-&gt;text();
                    $nodeKeyValue = $node-&gt;text();
                } else {
                    // this is a normal search, we want the value of that attribute of the tag.
                    $nodeKeyValue = $node-&gt;attr[$key];
                }
                if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &quot;testing node: &quot; . $node-&gt;tag . &quot; for attribute: &quot; . $key . $exp . $val . &quot; where nodes value is: &quot; . $nodeKeyValue);}

                //PaperG - If lowercase is set, do a case insensitive test of the value of the selector.
                if ($lowercase) {
                    $check = $this-&gt;match($exp, strtolower($val), strtolower($nodeKeyValue));
                } else {
                    $check = $this-&gt;match($exp, $val, $nodeKeyValue);
                }
                if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &quot;after match: &quot; . ($check ? &quot;true&quot; : &quot;false&quot;));}

                // handle multiple class
                if (!$check &amp;&amp; strcasecmp($key, &#x27;class&#x27;)===0) {
                    foreach (explode(&#x27; &#x27;,$node-&gt;attr[$key]) as $k) {
                        // Without this, there were cases where leading, trailing, or double spaces lead to our comparing blanks - bad form.
                        if (!empty($k)) {
                            if ($lowercase) {
                                $check = $this-&gt;match($exp, strtolower($val), strtolower($k));
                            } else {
                                $check = $this-&gt;match($exp, $val, $k);
                            }
                            if ($check) break;
                        }
                    }
                }
                if (!$check) $pass = false;
            }
            if ($pass) $ret[$i] = 1;
            unset($node);
        }
        // It&#x27;s passed by reference so this is actually what this function returns.
        if (is_object($debugObject)) {$debugObject-&gt;debugLog(1, &quot;EXIT - ret: &quot;, $ret);}
    }

    protected function match($exp, $pattern, $value) {
        global $debugObject;
        if (is_object($debugObject)) {$debugObject-&gt;debugLogEntry(1);}

        switch ($exp) {
            case &#x27;=&#x27;:
                return ($value===$pattern);
            case &#x27;!=&#x27;:
                return ($value!==$pattern);
            case &#x27;^=&#x27;:
                return preg_match(&quot;/^&quot;.preg_quote($pattern,&#x27;/&#x27;).&quot;/&quot;, $value);
            case &#x27;$=&#x27;:
                return preg_match(&quot;/&quot;.preg_quote($pattern,&#x27;/&#x27;).&quot;$/&quot;, $value);
            case &#x27;*=&#x27;:
                if ($pattern[0]==&#x27;/&#x27;) {
                    return preg_match($pattern, $value);
                }
                return preg_match(&quot;/&quot;.$pattern.&quot;/i&quot;, $value);
        }
        return false;
    }

    protected function parse_selector($selector_string) {
        global $debugObject;
        if (is_object($debugObject)) {$debugObject-&gt;debugLogEntry(1);}

        // pattern of CSS selectors, modified from mootools
        // Paperg: Add the colon to the attrbute, so that it properly finds &lt;tag attr:ibute=&quot;something&quot; &gt; like google does.
        // Note: if you try to look at this attribute, yo MUST use getAttribute since $dom-&gt;x:y will fail the php syntax check.
// Notice the \[ starting the attbute?  and the @? following?  This implies that an attribute can begin with an @ sign that is not captured.
// This implies that an html attribute specifier may start with an @ sign that is NOT captured by the expression.
// farther study is required to determine of this should be documented or removed.
//        $pattern = &quot;/([\w-:\*]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-]+)(?:([!*^$]?=)[\&quot;&#x27;]?(.*?)[\&quot;&#x27;]?)?\])?([\/, ]+)/is&quot;;
        $pattern = &quot;/([\w-:\*]*)(?:\#([\w-]+)|\.([\w-]+))?(?:\[@?(!?[\w-:]+)(?:([!*^$]?=)[\&quot;&#x27;]?(.*?)[\&quot;&#x27;]?)?\])?([\/, ]+)/is&quot;;
        preg_match_all($pattern, trim($selector_string).&#x27; &#x27;, $matches, PREG_SET_ORDER);
        if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &quot;Matches Array: &quot;, $matches);}

        $selectors = array();
        $result = array();
        //print_r($matches);

        foreach ($matches as $m) {
            $m[0] = trim($m[0]);
            if ($m[0]===&#x27;&#x27; || $m[0]===&#x27;/&#x27; || $m[0]===&#x27;//&#x27;) continue;
            // for browser generated xpath
            if ($m[1]===&#x27;tbody&#x27;) continue;

            list($tag, $key, $val, $exp, $no_key) = array($m[1], null, null, &#x27;=&#x27;, false);
            if (!empty($m[2])) {$key=&#x27;id&#x27;; $val=$m[2];}
            if (!empty($m[3])) {$key=&#x27;class&#x27;; $val=$m[3];}
            if (!empty($m[4])) {$key=$m[4];}
            if (!empty($m[5])) {$exp=$m[5];}
            if (!empty($m[6])) {$val=$m[6];}

            // convert to lowercase
            if ($this-&gt;dom-&gt;lowercase) {$tag=strtolower($tag); $key=strtolower($key);}
            //elements that do NOT have the specified attribute
            if (isset($key[0]) &amp;&amp; $key[0]===&#x27;!&#x27;) {$key=substr($key, 1); $no_key=true;}

            $result[] = array($tag, $key, $val, $exp, $no_key);
            if (trim($m[7])===&#x27;,&#x27;) {
                $selectors[] = $result;
                $result = array();
            }
        }
        if (count($result)&gt;0)
            $selectors[] = $result;
        return $selectors;
    }

    function __get($name) {
        if (isset($this-&gt;attr[$name]))
        {
            return $this-&gt;convert_text($this-&gt;attr[$name]);
        }
        switch ($name) {
            case &#x27;outertext&#x27;: return $this-&gt;outertext();
            case &#x27;innertext&#x27;: return $this-&gt;innertext();
            case &#x27;plaintext&#x27;: return $this-&gt;text();
            case &#x27;xmltext&#x27;: return $this-&gt;xmltext();
            default: return array_key_exists($name, $this-&gt;attr);
        }
    }

    function __set($name, $value) {
        switch ($name) {
            case &#x27;outertext&#x27;: return $this-&gt;_[HDOM_INFO_OUTER] = $value;
            case &#x27;innertext&#x27;:
                if (isset($this-&gt;_[HDOM_INFO_TEXT])) return $this-&gt;_[HDOM_INFO_TEXT] = $value;
                return $this-&gt;_[HDOM_INFO_INNER] = $value;
        }
        if (!isset($this-&gt;attr[$name])) {
            $this-&gt;_[HDOM_INFO_SPACE][] = array(&#x27; &#x27;, &#x27;&#x27;, &#x27;&#x27;);
            $this-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;
        }
        $this-&gt;attr[$name] = $value;
    }

    function __isset($name) {
        switch ($name) {
            case &#x27;outertext&#x27;: return true;
            case &#x27;innertext&#x27;: return true;
            case &#x27;plaintext&#x27;: return true;
        }
        //no value attr: nowrap, checked selected...
        return (array_key_exists($name, $this-&gt;attr)) ? true : isset($this-&gt;attr[$name]);
    }

    function __unset($name) {
        if (isset($this-&gt;attr[$name]))
            unset($this-&gt;attr[$name]);
    }

    // PaperG - Function to convert the text from one character set to another if the two sets are not the same.
    function convert_text($text) {
        global $debugObject;
        if (is_object($debugObject)) {$debugObject-&gt;debugLogEntry(1);}

        $converted_text = $text;

        $sourceCharset = &quot;&quot;;
        $targetCharset = &quot;&quot;;
        if ($this-&gt;dom) {
            $sourceCharset = strtoupper($this-&gt;dom-&gt;_charset);
            $targetCharset = strtoupper($this-&gt;dom-&gt;_target_charset);
        }
        if (is_object($debugObject)) {$debugObject-&gt;debugLog(3, &quot;source charset: &quot; . $sourceCharset . &quot; target charaset: &quot; . $targetCharset);}

        if (!empty($sourceCharset) &amp;&amp; !empty($targetCharset) &amp;&amp; (strcasecmp($sourceCharset, $targetCharset) != 0))
        {
            // Check if the reported encoding could have been incorrect and the text is actually already UTF-8
            if ((strcasecmp($targetCharset, &#x27;UTF-8&#x27;) == 0) &amp;&amp; ($this-&gt;is_utf8($text)))
            {
                $converted_text = $text;
            }
            else
            {
                $converted_text = iconv($sourceCharset, $targetCharset, $text);
            }
        }

        return $converted_text;
    }

    function is_utf8($string)
    {
        return (utf8_encode(utf8_decode($string)) == $string);
    }

    // camel naming conventions
    function getAllAttributes() {return $this-&gt;attr;}
    function getAttribute($name) {return $this-&gt;__get($name);}
    function setAttribute($name, $value) {$this-&gt;__set($name, $value);}
    function hasAttribute($name) {return $this-&gt;__isset($name);}
    function removeAttribute($name) {$this-&gt;__set($name, null);}
    function getElementById($id) {return $this-&gt;find(&quot;#$id&quot;, 0);}
    function getElementsById($id, $idx=null) {return $this-&gt;find(&quot;#$id&quot;, $idx);}
    function getElementByTagName($name) {return $this-&gt;find($name, 0);}
    function getElementsByTagName($name, $idx=null) {return $this-&gt;find($name, $idx);}
    function parentNode() {return $this-&gt;parent();}
    function childNodes($idx=-1) {return $this-&gt;children($idx);}
    function firstChild() {return $this-&gt;first_child();}
    function lastChild() {return $this-&gt;last_child();}
    function nextSibling() {return $this-&gt;next_sibling();}
    function previousSibling() {return $this-&gt;prev_sibling();}
}

/**
 * simple html dom parser
 * Paperg - in the find routine: allow us to specify that we want case insensitive testing of the value of the selector.
 * Paperg - change $size from protected to public so we can easily access it
 * Paperg - added ForceTagsClosed in the constructor which tells us whether we trust the html or not.  Default is to NOT trust it.
 *
 * @package PlaceLocalInclude
 */
class simple_html_dom {
    public $root = null;
    public $nodes = array();
    public $callback = null;
    public $lowercase = false;
    public $size;
    protected $pos;
    protected $doc;
    protected $char;
    protected $cursor;
    protected $parent;
    protected $noise = array();
    protected $token_blank = &quot; \t\r\n&quot;;
    protected $token_equal = &#x27; =/&gt;&#x27;;
    protected $token_slash = &quot; /&gt;\r\n\t&quot;;
    protected $token_attr = &#x27; &gt;&#x27;;
    protected $_charset = &#x27;&#x27;;
    protected $_target_charset = &#x27;&#x27;;
    protected $default_br_text = &quot;&quot;;

    // use isset instead of in_array, performance boost about 30%...
    protected $self_closing_tags = array(&#x27;img&#x27;=&gt;1, &#x27;br&#x27;=&gt;1, &#x27;input&#x27;=&gt;1, &#x27;meta&#x27;=&gt;1, &#x27;link&#x27;=&gt;1, &#x27;hr&#x27;=&gt;1, &#x27;base&#x27;=&gt;1, &#x27;embed&#x27;=&gt;1, &#x27;spacer&#x27;=&gt;1);
    protected $block_tags = array(&#x27;root&#x27;=&gt;1, &#x27;body&#x27;=&gt;1, &#x27;form&#x27;=&gt;1, &#x27;div&#x27;=&gt;1, &#x27;span&#x27;=&gt;1, &#x27;table&#x27;=&gt;1);
    // Known sourceforge issue #2977341
    // B tags that are not closed cause us to return everything to the end of the document.
    protected $optional_closing_tags = array(
        &#x27;tr&#x27;=&gt;array(&#x27;tr&#x27;=&gt;1, &#x27;td&#x27;=&gt;1, &#x27;th&#x27;=&gt;1),
        &#x27;th&#x27;=&gt;array(&#x27;th&#x27;=&gt;1),
        &#x27;td&#x27;=&gt;array(&#x27;td&#x27;=&gt;1),
        &#x27;li&#x27;=&gt;array(&#x27;li&#x27;=&gt;1),
        &#x27;dt&#x27;=&gt;array(&#x27;dt&#x27;=&gt;1, &#x27;dd&#x27;=&gt;1),
        &#x27;dd&#x27;=&gt;array(&#x27;dd&#x27;=&gt;1, &#x27;dt&#x27;=&gt;1),
        &#x27;dl&#x27;=&gt;array(&#x27;dd&#x27;=&gt;1, &#x27;dt&#x27;=&gt;1),
        &#x27;p&#x27;=&gt;array(&#x27;p&#x27;=&gt;1),
        &#x27;nobr&#x27;=&gt;array(&#x27;nobr&#x27;=&gt;1),
        &#x27;b&#x27;=&gt;array(&#x27;b&#x27;=&gt;1),
    );

    function __construct($str=null, $lowercase=true, $forceTagsClosed=true, $target_charset=DEFAULT_TARGET_CHARSET, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT) {
        if ($str) {
            if (preg_match(&quot;/^http:\/\//i&quot;,$str) || is_file($str))
                $this-&gt;load_file($str);
            else
                $this-&gt;load($str, $lowercase, $stripRN, $defaultBRText);
        }
        // Forcing tags to be closed implies that we don&#x27;t trust the html, but it can lead to parsing errors if we SHOULD trust the html.
        if (!$forceTagsClosed) {
            $this-&gt;optional_closing_array=array();
        }
        $this-&gt;_target_charset = $target_charset;
    }

    function __destruct() {
        $this-&gt;clear();
    }

    // load html from string
    function load($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT) {
        global $debugObject;

        // prepare
        $this-&gt;prepare($str, $lowercase, $stripRN, $defaultBRText);
        // strip out comments
        $this-&gt;remove_noise(&quot;&#x27;&lt;!--(.*?)--&gt;&#x27;is&quot;);
        // strip out cdata
        $this-&gt;remove_noise(&quot;&#x27;&lt;!\[CDATA\[(.*?)\]\]&gt;&#x27;is&quot;, true);
        // Per sourceforge http://sourceforge.net/tracker/?func=detail&amp;aid=2949097&amp;group_id=218559&amp;atid=1044037
        // Script tags removal now preceeds style tag removal.
        // strip out &lt;script&gt; tags
        $this-&gt;remove_noise(&quot;&#x27;&lt;\s*script[^&gt;]*[^/]&gt;(.*?)&lt;\s*/\s*script\s*&gt;&#x27;is&quot;);
        $this-&gt;remove_noise(&quot;&#x27;&lt;\s*script\s*&gt;(.*?)&lt;\s*/\s*script\s*&gt;&#x27;is&quot;);
        // strip out &lt;style&gt; tags
        $this-&gt;remove_noise(&quot;&#x27;&lt;\s*style[^&gt;]*[^/]&gt;(.*?)&lt;\s*/\s*style\s*&gt;&#x27;is&quot;);
        $this-&gt;remove_noise(&quot;&#x27;&lt;\s*style\s*&gt;(.*?)&lt;\s*/\s*style\s*&gt;&#x27;is&quot;);
        // strip out preformatted tags
        $this-&gt;remove_noise(&quot;&#x27;&lt;\s*(?:code)[^&gt;]*&gt;(.*?)&lt;\s*/\s*(?:code)\s*&gt;&#x27;is&quot;);
        // strip out server side scripts
        $this-&gt;remove_noise(&quot;&#x27;(&lt;\?)(.*?)(\?&gt;)&#x27;s&quot;, true);
        // strip smarty scripts
        $this-&gt;remove_noise(&quot;&#x27;(\{\w)(.*?)(\})&#x27;s&quot;, true);

        // parsing
        while ($this-&gt;parse());
        // end
        $this-&gt;root-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;
        $this-&gt;parse_charset();
    }

    // load html from file
    function load_file() {
        $args = func_get_args();
        $this-&gt;load(call_user_func_array(&#x27;file_get_contents&#x27;, $args), true);
        // Per the simple_html_dom repositiry this is a planned upgrade to the codebase.
        // Throw an error if we can&#x27;t properly load the dom.
        if (($error=error_get_last())!==null) {
            $this-&gt;clear();
            return false;
        }
    }

    // set callback function
    function set_callback($function_name) {
        $this-&gt;callback = $function_name;
    }

    // remove callback function
    function remove_callback() {
        $this-&gt;callback = null;
    }

    // save dom as string
    function save($filepath=&#x27;&#x27;) {
        $ret = $this-&gt;root-&gt;innertext();
        if ($filepath!==&#x27;&#x27;) file_put_contents($filepath, $ret, LOCK_EX);
        return $ret;
    }

    // find dom node by css selector
    // Paperg - allow us to specify that we want case insensitive testing of the value of the selector.
    function find($selector, $idx=null, $lowercase=false) {
        return $this-&gt;root-&gt;find($selector, $idx, $lowercase);
    }

    // clean up memory due to php5 circular references memory leak...
    function clear() {
        foreach ($this-&gt;nodes as $n) {$n-&gt;clear(); $n = null;}
        // This add next line is documented in the sourceforge repository. 2977248 as a fix for ongoing memory leaks that occur even with the use of clear.
        if (isset($this-&gt;children)) foreach ($this-&gt;children as $n) {$n-&gt;clear(); $n = null;}
        if (isset($this-&gt;parent)) {$this-&gt;parent-&gt;clear(); unset($this-&gt;parent);}
        if (isset($this-&gt;root)) {$this-&gt;root-&gt;clear(); unset($this-&gt;root);}
        unset($this-&gt;doc);
        unset($this-&gt;noise);
    }

    function dump($show_attr=true) {
        $this-&gt;root-&gt;dump($show_attr);
    }

    // prepare HTML data and init everything
    protected function prepare($str, $lowercase=true, $stripRN=true, $defaultBRText=DEFAULT_BR_TEXT) {
        $this-&gt;clear();

        // set the length of content before we do anything to it.
        $this-&gt;size = strlen($str);

        //before we save the string as the doc...  strip out the \r \n&#x27;s if we are told to.
        if ($stripRN) {
            $str = str_replace(&quot;\r&quot;, &quot; &quot;, $str);
            $str = str_replace(&quot;\n&quot;, &quot; &quot;, $str);
        }

        $this-&gt;doc = $str;
        $this-&gt;pos = 0;
        $this-&gt;cursor = 1;
        $this-&gt;noise = array();
        $this-&gt;nodes = array();
        $this-&gt;lowercase = $lowercase;
        $this-&gt;default_br_text = $defaultBRText;
        $this-&gt;root = new simple_html_dom_node($this);
        $this-&gt;root-&gt;tag = &#x27;root&#x27;;
        $this-&gt;root-&gt;_[HDOM_INFO_BEGIN] = -1;
        $this-&gt;root-&gt;nodetype = HDOM_TYPE_ROOT;
        $this-&gt;parent = $this-&gt;root;
        if ($this-&gt;size&gt;0) $this-&gt;char = $this-&gt;doc[0];
    }

    // parse html content
    protected function parse() {
        if (($s = $this-&gt;copy_until_char(&#x27;&lt;&#x27;))===&#x27;&#x27;)
            return $this-&gt;read_tag();

        // text
        $node = new simple_html_dom_node($this);
        ++$this-&gt;cursor;
        $node-&gt;_[HDOM_INFO_TEXT] = $s;
        $this-&gt;link_nodes($node, false);
        return true;
    }

    // PAPERG - dkchou - added this to try to identify the character set of the page we have just parsed so we know better how to spit it out later.
    // NOTE:  IF you provide a routine called get_last_retrieve_url_contents_content_type which returns the CURLINFO_CONTENT_TYPE fromt he last curl_exec
    // (or the content_type header fromt eh last transfer), we will parse THAT, and if a charset is specified, we will use it over any other mechanism.
    protected function parse_charset()
    {
        global $debugObject;

        $charset = null;

        if (function_exists(&#x27;get_last_retrieve_url_contents_content_type&#x27;))
        {
            $contentTypeHeader = get_last_retrieve_url_contents_content_type();
            $success = preg_match(&#x27;/charset=(.+)/&#x27;, $contentTypeHeader, $matches);
            if ($success)
            {
                $charset = $matches[1];
                if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;header content-type found charset of: &#x27; . $charset);}
            }

        }

        if (empty($charset))
        {
            $el = $this-&gt;root-&gt;find(&#x27;meta[http-equiv=Content-Type]&#x27;,0);
            if (!empty($el))
            {
                $fullvalue = $el-&gt;content;
                if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;meta content-type tag found&#x27; . $fullValue);}

                if (!empty($fullvalue))
                {
                    $success = preg_match(&#x27;/charset=(.+)/&#x27;, $fullvalue, $matches);
                    if ($success)
                    {
                        $charset = $matches[1];
                    }
                    else
                    {
                        // If there is a meta tag, and they don&#x27;t specify the character set, research says that it&#x27;s typically ISO-8859-1
                        if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;meta content-type tag couldn\&#x27;t be parsed. using iso-8859 default.&#x27;);}
                        $charset = &#x27;ISO-8859-1&#x27;;
                    }
                }
            }
        }

        // If we couldn&#x27;t find a charset above, then lets try to detect one based on the text we got...
        if (empty($charset))
        {
            // Have php try to detect the encoding from the text given to us.
            $charset = mb_detect_encoding($this-&gt;root-&gt;plaintext . &quot;ascii&quot;, $encoding_list = array( &quot;UTF-8&quot;, &quot;CP1252&quot; ) );
            if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;mb_detect found: &#x27; . $charset);}

            // and if this doesn&#x27;t work...  then we need to just wrongheadedly assume it&#x27;s UTF-8 so that we can move on - cause this will usually give us most of what we need...
            if ($charset === false)
            {
                if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;since mb_detect failed - using default of utf-8&#x27;);}
                $charset = &#x27;UTF-8&#x27;;
            }
        }

        // Since CP1252 is a superset, if we get one of it&#x27;s subsets, we want it instead.
        if ((strtolower($charset) == strtolower(&#x27;ISO-8859-1&#x27;)) || (strtolower($charset) == strtolower(&#x27;Latin1&#x27;)) || (strtolower($charset) == strtolower(&#x27;Latin-1&#x27;)))
        {
            if (is_object($debugObject)) {$debugObject-&gt;debugLog(2, &#x27;replacing &#x27; . $charset . &#x27; with CP1252 as its a superset&#x27;);}
            $charset = &#x27;CP1252&#x27;;
        }

        if (is_object($debugObject)) {$debugObject-&gt;debugLog(1, &#x27;EXIT - &#x27; . $charset);}

        return $this-&gt;_charset = $charset;
    }

    // read tag info
    protected function read_tag() {
        if ($this-&gt;char!==&#x27;&lt;&#x27;) {
            $this-&gt;root-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;
            return false;
        }
        $begin_tag_pos = $this-&gt;pos;
        $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next

        // end tag
        if ($this-&gt;char===&#x27;/&#x27;) {
            $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
            // This represetns the change in the simple_html_dom trunk from revision 180 to 181.
            // $this-&gt;skip($this-&gt;token_blank_t);
            $this-&gt;skip($this-&gt;token_blank);
            $tag = $this-&gt;copy_until_char(&#x27;&gt;&#x27;);

            // skip attributes in end tag
            if (($pos = strpos($tag, &#x27; &#x27;))!==false)
                $tag = substr($tag, 0, $pos);

            $parent_lower = strtolower($this-&gt;parent-&gt;tag);
            $tag_lower = strtolower($tag);

            if ($parent_lower!==$tag_lower) {
                if (isset($this-&gt;optional_closing_tags[$parent_lower]) &amp;&amp; isset($this-&gt;block_tags[$tag_lower])) {
                    $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;
                    $org_parent = $this-&gt;parent;

                    while (($this-&gt;parent-&gt;parent) &amp;&amp; strtolower($this-&gt;parent-&gt;tag)!==$tag_lower)
                        $this-&gt;parent = $this-&gt;parent-&gt;parent;

                    if (strtolower($this-&gt;parent-&gt;tag)!==$tag_lower) {
                        $this-&gt;parent = $org_parent; // restore origonal parent
                        if ($this-&gt;parent-&gt;parent) $this-&gt;parent = $this-&gt;parent-&gt;parent;
                        $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;
                        return $this-&gt;as_text_node($tag);
                    }
                }
                else if (($this-&gt;parent-&gt;parent) &amp;&amp; isset($this-&gt;block_tags[$tag_lower])) {
                    $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;
                    $org_parent = $this-&gt;parent;

                    while (($this-&gt;parent-&gt;parent) &amp;&amp; strtolower($this-&gt;parent-&gt;tag)!==$tag_lower)
                        $this-&gt;parent = $this-&gt;parent-&gt;parent;

                    if (strtolower($this-&gt;parent-&gt;tag)!==$tag_lower) {
                        $this-&gt;parent = $org_parent; // restore origonal parent
                        $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;
                        return $this-&gt;as_text_node($tag);
                    }
                }
                else if (($this-&gt;parent-&gt;parent) &amp;&amp; strtolower($this-&gt;parent-&gt;parent-&gt;tag)===$tag_lower) {
                    $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;
                    $this-&gt;parent = $this-&gt;parent-&gt;parent;
                }
                else
                    return $this-&gt;as_text_node($tag);
            }

            $this-&gt;parent-&gt;_[HDOM_INFO_END] = $this-&gt;cursor;
            if ($this-&gt;parent-&gt;parent) $this-&gt;parent = $this-&gt;parent-&gt;parent;

            $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
            return true;
        }

        $node = new simple_html_dom_node($this);
        $node-&gt;_[HDOM_INFO_BEGIN] = $this-&gt;cursor;
        ++$this-&gt;cursor;
        $tag = $this-&gt;copy_until($this-&gt;token_slash);
        $node-&gt;tag_start = $begin_tag_pos;

        // doctype, cdata &amp; comments...
        if (isset($tag[0]) &amp;&amp; $tag[0]===&#x27;!&#x27;) {
            $node-&gt;_[HDOM_INFO_TEXT] = &#x27;&lt;&#x27; . $tag . $this-&gt;copy_until_char(&#x27;&gt;&#x27;);

            if (isset($tag[2]) &amp;&amp; $tag[1]===&#x27;-&#x27; &amp;&amp; $tag[2]===&#x27;-&#x27;) {
                $node-&gt;nodetype = HDOM_TYPE_COMMENT;
                $node-&gt;tag = &#x27;comment&#x27;;
            } else {
                $node-&gt;nodetype = HDOM_TYPE_UNKNOWN;
                $node-&gt;tag = &#x27;unknown&#x27;;
            }
            if ($this-&gt;char===&#x27;&gt;&#x27;) $node-&gt;_[HDOM_INFO_TEXT].=&#x27;&gt;&#x27;;
            $this-&gt;link_nodes($node, true);
            $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
            return true;
        }

        // text
        if ($pos=strpos($tag, &#x27;&lt;&#x27;)!==false) {
            $tag = &#x27;&lt;&#x27; . substr($tag, 0, -1);
            $node-&gt;_[HDOM_INFO_TEXT] = $tag;
            $this-&gt;link_nodes($node, false);
            $this-&gt;char = $this-&gt;doc[--$this-&gt;pos]; // prev
            return true;
        }

        if (!preg_match(&quot;/^[\w-:]+$/&quot;, $tag)) {
            $node-&gt;_[HDOM_INFO_TEXT] = &#x27;&lt;&#x27; . $tag . $this-&gt;copy_until(&#x27;&lt;&gt;&#x27;);
            if ($this-&gt;char===&#x27;&lt;&#x27;) {
                $this-&gt;link_nodes($node, false);
                return true;
            }

            if ($this-&gt;char===&#x27;&gt;&#x27;) $node-&gt;_[HDOM_INFO_TEXT].=&#x27;&gt;&#x27;;
            $this-&gt;link_nodes($node, false);
            $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
            return true;
        }

        // begin tag
        $node-&gt;nodetype = HDOM_TYPE_ELEMENT;
        $tag_lower = strtolower($tag);
        $node-&gt;tag = ($this-&gt;lowercase) ? $tag_lower : $tag;

        // handle optional closing tags
        if (isset($this-&gt;optional_closing_tags[$tag_lower]) ) {
            while (isset($this-&gt;optional_closing_tags[$tag_lower][strtolower($this-&gt;parent-&gt;tag)])) {
                $this-&gt;parent-&gt;_[HDOM_INFO_END] = 0;
                $this-&gt;parent = $this-&gt;parent-&gt;parent;
            }
            $node-&gt;parent = $this-&gt;parent;
        }

        $guard = 0; // prevent infinity loop
        $space = array($this-&gt;copy_skip($this-&gt;token_blank), &#x27;&#x27;, &#x27;&#x27;);

        // attributes
        do
        {
            if ($this-&gt;char!==null &amp;&amp; $space[0]===&#x27;&#x27;) break;
            $name = $this-&gt;copy_until($this-&gt;token_equal);
            if ($guard===$this-&gt;pos) {
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                continue;
            }
            $guard = $this-&gt;pos;

            // handle endless &#x27;&lt;&#x27;
            if ($this-&gt;pos&gt;=$this-&gt;size-1 &amp;&amp; $this-&gt;char!==&#x27;&gt;&#x27;) {
                $node-&gt;nodetype = HDOM_TYPE_TEXT;
                $node-&gt;_[HDOM_INFO_END] = 0;
                $node-&gt;_[HDOM_INFO_TEXT] = &#x27;&lt;&#x27;.$tag . $space[0] . $name;
                $node-&gt;tag = &#x27;text&#x27;;
                $this-&gt;link_nodes($node, false);
                return true;
            }

            // handle mismatch &#x27;&lt;&#x27;
            if ($this-&gt;doc[$this-&gt;pos-1]==&#x27;&lt;&#x27;) {
                $node-&gt;nodetype = HDOM_TYPE_TEXT;
                $node-&gt;tag = &#x27;text&#x27;;
                $node-&gt;attr = array();
                $node-&gt;_[HDOM_INFO_END] = 0;
                $node-&gt;_[HDOM_INFO_TEXT] = substr($this-&gt;doc, $begin_tag_pos, $this-&gt;pos-$begin_tag_pos-1);
                $this-&gt;pos -= 2;
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                $this-&gt;link_nodes($node, false);
                return true;
            }

            if ($name!==&#x27;/&#x27; &amp;&amp; $name!==&#x27;&#x27;) {
                $space[1] = $this-&gt;copy_skip($this-&gt;token_blank);
                $name = $this-&gt;restore_noise($name);
                if ($this-&gt;lowercase) $name = strtolower($name);
                if ($this-&gt;char===&#x27;=&#x27;) {
                    $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                    $this-&gt;parse_attr($node, $name, $space);
                }
                else {
                    //no value attr: nowrap, checked selected...
                    $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;
                    $node-&gt;attr[$name] = true;
                    if ($this-&gt;char!=&#x27;&gt;&#x27;) $this-&gt;char = $this-&gt;doc[--$this-&gt;pos]; // prev
                }
                $node-&gt;_[HDOM_INFO_SPACE][] = $space;
                $space = array($this-&gt;copy_skip($this-&gt;token_blank), &#x27;&#x27;, &#x27;&#x27;);
            }
            else
                break;
        } while ($this-&gt;char!==&#x27;&gt;&#x27; &amp;&amp; $this-&gt;char!==&#x27;/&#x27;);

        $this-&gt;link_nodes($node, true);
        $node-&gt;_[HDOM_INFO_ENDSPACE] = $space[0];

        // check self closing
        if ($this-&gt;copy_until_char_escape(&#x27;&gt;&#x27;)===&#x27;/&#x27;) {
            $node-&gt;_[HDOM_INFO_ENDSPACE] .= &#x27;/&#x27;;
            $node-&gt;_[HDOM_INFO_END] = 0;
        }
        else {
            // reset parent
            if (!isset($this-&gt;self_closing_tags[strtolower($node-&gt;tag)])) $this-&gt;parent = $node;
        }
        $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next

        // If it&#x27;s a BR tag, we need to set it&#x27;s text to the default text.
        // This way when we see it in plaintext, we can generate formatting that the user wants.
        if ($node-&gt;tag == &quot;br&quot;) {
            $node-&gt;_[HDOM_INFO_INNER] = $this-&gt;default_br_text;
        }

        return true;
    }

    // parse attributes
    protected function parse_attr($node, $name, &amp;$space) {
        // Per sourceforge: http://sourceforge.net/tracker/?func=detail&amp;aid=3061408&amp;group_id=218559&amp;atid=1044037
        // If the attribute is already defined inside a tag, only pay atetntion to the first one as opposed to the last one.
        if (isset($node-&gt;attr[$name]))
        {
            return;
        }

        $space[2] = $this-&gt;copy_skip($this-&gt;token_blank);
        switch ($this-&gt;char) {
            case &#x27;&quot;&#x27;:
                $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_DOUBLE;
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until_char_escape(&#x27;&quot;&#x27;));
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                break;
            case &#x27;\&#x27;&#x27;:
                $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_SINGLE;
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until_char_escape(&#x27;\&#x27;&#x27;));
                $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
                break;
            default:
                $node-&gt;_[HDOM_INFO_QUOTE][] = HDOM_QUOTE_NO;
                $node-&gt;attr[$name] = $this-&gt;restore_noise($this-&gt;copy_until($this-&gt;token_attr));
        }
        // PaperG: Attributes should not have \r or \n in them, that counts as html whitespace.
        $node-&gt;attr[$name] = str_replace(&quot;\r&quot;, &quot;&quot;, $node-&gt;attr[$name]);
        $node-&gt;attr[$name] = str_replace(&quot;\n&quot;, &quot;&quot;, $node-&gt;attr[$name]);
        // PaperG: If this is a &quot;class&quot; selector, lets get rid of the preceeding and trailing space since some people leave it in the multi class case.
        if ($name == &quot;class&quot;) {
            $node-&gt;attr[$name] = trim($node-&gt;attr[$name]);
        }
    }

    // link node&#x27;s parent
    protected function link_nodes(&amp;$node, $is_child) {
        $node-&gt;parent = $this-&gt;parent;
        $this-&gt;parent-&gt;nodes[] = $node;
        if ($is_child)
            $this-&gt;parent-&gt;children[] = $node;
    }

    // as a text node
    protected function as_text_node($tag) {
        $node = new simple_html_dom_node($this);
        ++$this-&gt;cursor;
        $node-&gt;_[HDOM_INFO_TEXT] = &#x27;&lt;/&#x27; . $tag . &#x27;&gt;&#x27;;
        $this-&gt;link_nodes($node, false);
        $this-&gt;char = (++$this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
        return true;
    }

    protected function skip($chars) {
        $this-&gt;pos += strspn($this-&gt;doc, $chars, $this-&gt;pos);
        $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
    }

    protected function copy_skip($chars) {
        $pos = $this-&gt;pos;
        $len = strspn($this-&gt;doc, $chars, $pos);
        $this-&gt;pos += $len;
        $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
        if ($len===0) return &#x27;&#x27;;
        return substr($this-&gt;doc, $pos, $len);
    }

    protected function copy_until($chars) {
        $pos = $this-&gt;pos;
        $len = strcspn($this-&gt;doc, $chars, $pos);
        $this-&gt;pos += $len;
        $this-&gt;char = ($this-&gt;pos&lt;$this-&gt;size) ? $this-&gt;doc[$this-&gt;pos] : null; // next
        return substr($this-&gt;doc, $pos, $len);
    }

    protected function copy_until_char($char) {
        if ($this-&gt;char===null) return &#x27;&#x27;;

        if (($pos = strpos($this-&gt;doc, $char, $this-&gt;pos))===false) {
            $ret = substr($this-&gt;doc, $this-&gt;pos, $this-&gt;size-$this-&gt;pos);
            $this-&gt;char = null;
            $this-&gt;pos = $this-&gt;size;
            return $ret;
        }

        if ($pos===$this-&gt;pos) return &#x27;&#x27;;
        $pos_old = $this-&gt;pos;
        $this-&gt;char = $this-&gt;doc[$pos];
        $this-&gt;pos = $pos;
        return substr($this-&gt;doc, $pos_old, $pos-$pos_old);
    }

    protected function copy_until_char_escape($char) {
        if ($this-&gt;char===null) return &#x27;&#x27;;

        $start = $this-&gt;pos;
        while (1) {
            if (($pos = strpos($this-&gt;doc, $char, $start))===false) {
                $ret = substr($this-&gt;doc, $this-&gt;pos, $this-&gt;size-$this-&gt;pos);
                $this-&gt;char = null;
                $this-&gt;pos = $this-&gt;size;
                return $ret;
            }

            if ($pos===$this-&gt;pos) return &#x27;&#x27;;

            if ($this-&gt;doc[$pos-1]===&#x27;\\&#x27;) {
                $start = $pos+1;
                continue;
            }

            $pos_old = $this-&gt;pos;
            $this-&gt;char = $this-&gt;doc[$pos];
            $this-&gt;pos = $pos;
            return substr($this-&gt;doc, $pos_old, $pos-$pos_old);
        }
    }

    // remove noise from html content
    protected function remove_noise($pattern, $remove_tag=false) {
        $count = preg_match_all($pattern, $this-&gt;doc, $matches, PREG_SET_ORDER|PREG_OFFSET_CAPTURE);

        for ($i=$count-1; $i&gt;-1; --$i) {
            $key = &#x27;___noise___&#x27;.sprintf(&#x27;% 3d&#x27;, count($this-&gt;noise)+100);
            $idx = ($remove_tag) ? 0 : 1;
            $this-&gt;noise[$key] = $matches[$i][$idx][0];
            $this-&gt;doc = substr_replace($this-&gt;doc, $key, $matches[$i][$idx][1], strlen($matches[$i][$idx][0]));
        }

        // reset the length of content
        $this-&gt;size = strlen($this-&gt;doc);
        if ($this-&gt;size&gt;0) $this-&gt;char = $this-&gt;doc[0];
    }

    // restore noise to html content
    function restore_noise($text) {
        while (($pos=strpos($text, &#x27;___noise___&#x27;))!==false) {
            $key = &#x27;___noise___&#x27;.$text[$pos+11].$text[$pos+12].$text[$pos+13];
            if (isset($this-&gt;noise[$key]))
                $text = substr($text, 0, $pos).$this-&gt;noise[$key].substr($text, $pos+14);
        }
        return $text;
    }

    function __toString() {
        return $this-&gt;root-&gt;innertext();
    }

    function __get($name) {
        switch ($name) {
            case &#x27;outertext&#x27;:
                return $this-&gt;root-&gt;innertext();
            case &#x27;innertext&#x27;:
                return $this-&gt;root-&gt;innertext();
            case &#x27;plaintext&#x27;:
                return $this-&gt;root-&gt;text();
            case &#x27;charset&#x27;:
                return $this-&gt;_charset;
            case &#x27;target_charset&#x27;:
                return $this-&gt;_target_charset;
        }
    }

    // camel naming conventions
    function childNodes($idx=-1) {return $this-&gt;root-&gt;childNodes($idx);}
    function firstChild() {return $this-&gt;root-&gt;first_child();}
    function lastChild() {return $this-&gt;root-&gt;last_child();}
    function getElementById($id) {return $this-&gt;find(&quot;#$id&quot;, 0);}
    function getElementsById($id, $idx=null) {return $this-&gt;find(&quot;#$id&quot;, $idx);}
    function getElementByTagName($name) {return $this-&gt;find($name, 0);}
    function getElementsByTagName($name, $idx=-1) {return $this-&gt;find($name, $idx);}
    function loadFile() {$args = func_get_args();$this-&gt;load_file($args);}
}

?&gt;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
